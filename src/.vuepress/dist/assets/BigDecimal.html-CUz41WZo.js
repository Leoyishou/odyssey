import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,f as n,d as t,e as h,b as s,r as p,o as k}from"./app-DokaGNO4.js";const d={};function r(g,i){const a=p("font");return k(),l("div",null,[i[1]||(i[1]=n(`<p>ROUND_HALF_UP 四舍五入</p><p>compareTo</p><h2 id="int、float、double-转-bigdecimal" tabindex="-1"><a class="header-anchor" href="#int、float、double-转-bigdecimal"><span>int、float、double 转 BigDecimal</span></a></h2><p>不要直接用 new 方法，而是用 value of</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] args) {  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    double</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0.05</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a));</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a));</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="典型回答" tabindex="-1"><a class="header-anchor" href="#典型回答"><span>典型回答</span></a></h1><p>有区别，而且区别很大。</p><p>因为double是不精确的，所以使用一个不精确的数字来创建BigDecimal，得到的数字也是不精确的。如0.1这个数字，double只能表示他的近似值。</p><p>所以，<strong>当我们使用new BigDecimal(0.1)创建一个BigDecimal 的时候，其实创建出来的值并不是正好等于0.1的。</strong></p><p>而是0.1000000000000000055511151231257827021181583404541015625。这是因为double自身表示的只是一个近似值。</p><p>而对于BigDecimal(String) ，当我们使用new BigDecimal(&quot;0.1&quot;)创建一个BigDecimal 的时候，其实创建出来的值正好就是等于0.1的。</p><p>那么他的标度也就是1</p><h1 id="扩展知识" tabindex="-1"><a class="header-anchor" href="#扩展知识"><span>扩展知识</span></a></h1><p>在《阿里巴巴Java开发手册》中有一条建议，或者说是要求：</p><h3 id="bigdecimal如何精确计数" tabindex="-1"><a class="header-anchor" href="#bigdecimal如何精确计数"><span>BigDecimal如何精确计数？</span></a></h3><p>如果大家看过BigDecimal的源码，其实可以发现，<strong>实际上一个BigDecimal是通过一个&quot;无标度值&quot;和一个&quot;标度&quot;来表示一个数的。</strong></p><blockquote><p><strong>无标度值（Unscaled Value）</strong>：这是一个整数，表示BigDecimal的实际数值。</p><p><strong>标度（Scale）</strong>：这是一个整数，表示小数点后的位数。</p><p>BigDecimal的实际数值计算公式为：unscaledValue × 10^(-scale)。</p></blockquote><p>假设有一个BigDecimal表示的数值是123.45，那么无标度值（Unscaled Value）是12345。标度（Scale）是2。因为123.45 = 12345 × 10^(-2)。</p><p>涉及到的字段就是这几个：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BigDecimal</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Number</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Comparable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BigDecimal</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BigInteger</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> intVal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> scale</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> transient</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> intCompact</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于无标度值的压缩机制大家了解即可，不是本文的重点，大家只需要知道BigDecimal主要是通过一个无标度值和标度来表示的就行了。</p><p><strong>那么标度到底是什么呢？</strong></p><p>除了scale这个字段，在BigDecimal中还提供了scale()方法，用来返回这个BigDecimal的标度。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * Returns the &lt;i&gt;scale&lt;/i&gt; of this {@code BigDecimal}.  If zero</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * or positive, the scale is the number of digits to the right of</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * the decimal point.  If negative, the unscaled value of the</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * number is multiplied by ten to the power of the negation of the</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * scale.  For example, a scale of {@code -3} means the unscaled</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * value is multiplied by 1000.</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * </span><span style="--shiki-light:#A626A4;--shiki-light-font-style:italic;--shiki-dark:#C678DD;--shiki-dark-font-style:italic;">@return</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> the scale of this {@code BigDecimal}.</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> scale</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> scale</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，scale到底表示的是什么，其实上面的注释已经说的很清楚了。</p><blockquote><p>当标度为正数时，它表示小数点后的位数。例如，在数字123.45中，他的无标度值为12345，标度是2。</p><p>当标度为零时，BigDecimal表示一个整数。</p><p>当标度为负数时，它表示小数点向左移动的位数，相当于将数字乘以 10 的绝对值的次方。例如，一个数值为1234500，那么他可以用value是12345，scale为-2来表示，因为1234500 * 10^(-2) = 12345。（当需要处理非常大的整数时，可以使用负数的标度来指定小数点左侧的位数。这在需要保持整数的精度而又不想丢失尾部零位时很有用。）</p></blockquote><p><strong>而二进制无法表示的0.1，使用BigDecimal就可以表示了，及通过无标度值1和标度1来表示。</strong></p><p>我们都知道，想要创建一个对象，需要使用该类的构造方法，在BigDecimal中一共有以下4个构造方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(String)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上四个方法，创建出来的BigDecimal的标度（scale）是不同的。</p><p>其中 BigDecimal(int)和BigDecimal(long) 比较简单，因为都是整数，所以他们的标度都是0。</p><p>而BigDecimal(double) 和BigDecimal(String)的标度就有很多学问了。</p><h3 id="bigdecimal-double-有什么问题" tabindex="-1"><a class="header-anchor" href="#bigdecimal-double-有什么问题"><span>BigDecimal(double)有什么问题</span></a></h3><p>BigDecimal中提供了一个通过double创建BigDecimal的方法——BigDecimal(double) ，但是，同时也给我们留了一个坑！</p><p>因为我们知道，double表示的小数是不精确的，如0.1这个数字，double只能表示他的近似值。</p><p>所以，<strong>当我们使用new BigDecimal(0.1)创建一个BigDecimal 的时候，其实创建出来的值并不是正好等于0.1的。</strong></p><p>而是0.1000000000000000055511151231257827021181583404541015625。这是因为double自身表示的只是一个近似值。</p><p><strong>所以，如果我们在代码中，使用BigDecimal(double) 来创建一个BigDecimal的话，那么是损失了精度的，这是极其严重的。</strong></p><h3 id="使用bigdecimal-string-创建" tabindex="-1"><a class="header-anchor" href="#使用bigdecimal-string-创建"><span>使用BigDecimal(String)创建</span></a></h3><p>那么，该如何创建一个精确的BigDecimal来表示小数呢，答案是使用String创建。</p><p>而对于BigDecimal(String) ，当我们使用new BigDecimal(&quot;0.1&quot;)创建一个BigDecimal 的时候，其实创建出来的值正好就是等于0.1的。</p><p>那么他的标度也就是1。</p><p>但是需要注意的是，new BigDecimal(&quot;0.10000&quot;)和new BigDecimal(&quot;0.1&quot;)这两个数的标度分别是5和1，如果使用BigDecimal的equals方法比较，得到的结果是false。</p><p>那么，想要创建一个能精确的表示0.1的BigDecimal，请使用以下两种方式：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BigDecimal</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> recommend1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;0.1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BigDecimal</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> recommend2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> BigDecimal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，留一个思考题，BigDecimal.valueOf()是调用Double.toString方法实现的，那么，既然double都是不精确的，BigDecimal.valueOf(0.1)怎么保证精确呢？</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>因为计算机采用二进制处理数据，但是很多小数，如0.1的二进制是一个无限循环小数，而这种数字在计算机中是无法精确表示的。</p><p>所以，人们采用了一种通过近似值的方式在计算机中表示，于是就有了单精度浮点数和双精度浮点数等。</p><p>所以，作为单精度浮点数的float和双精度浮点数的double，在表示小数的时候只是近似值，并不是真实值。</p><p>所以，当使用BigDecimal(Double)创建一个的时候，得到的BigDecimal是损失了精度的。</p><p>而使用一个损失了精度的数字进行计算，得到的结果也是不精确的。</p><p>想要避免这个问题，可以通过BigDecimal(String)的方式创建BigDecimal，这样的情况下，0.1就会被精确的表示出来。</p><p>其表现形式是一个无标度数值1，和一个标度1的组合。</p><h1 id="典型回答-1" tabindex="-1"><a class="header-anchor" href="#典型回答-1"><span>典型回答</span></a></h1><p>大家都知道，不能用Float和Double来表示金额，会存在丢失精度的问题。</p><p><a href="https://www.yuque.com/hollis666/vgoof0/vmrkz84g8c6ypu5s" target="_blank" rel="noopener noreferrer">✅为什么不能用浮点数表示金额？</a></p><p>那么要表示金额，业内有两种做法：</p><p>1、单位为分，数据库存bigint，代码中用long。如100.16元，存储为10016（在不考虑多币种的情况下）。</p><p>2、单位为元，数据库用decimal，代码中用BigDecimal（<u>我们一般数据库存储的是decimal(18,6)</u>）。如100.16元，直接存成100.16</p><p>这两种，其实我们都用过，而且现在也还都在用，因为他们都有各自的优缺点以及适用场景。</p><p>首先说<strong>BigDecimal</strong>，<code>BigDecimal</code> 是 Java 中用于精确计算的类，特别适合于需要高精度数值计算的场景，如金融、计量和工程等领域。其特点如下：</p><ul><li><strong>精确度高</strong>：<code>BigDecimal</code> 可以表示非常大或非常精确的小数，而不会出现浮点数那样的舍入误差。</li><li><strong>灵活的数学运算</strong>：它提供各种方法进行精确的算术操作，包括加减乘除和四舍五入等。</li><li><strong>控制舍入行为</strong>：在进行数学运算时，你可以指定舍入模式，这对于金融计算非常重要。</li></ul><p><strong>所以，BigDecimal的适用场景是需要高精度计算的金融应用，如货币计算、利率计算等。比如我们的结算系统、支付系统、账单系统等，都是用BigDecimal的。</strong></p><p>其次，再说Long，<code>long</code> 是 Java 的一种基本数据类型，用于表示没有小数部分的整数。其特点如下：</p><ul><li><strong>性能高</strong>：作为基本数据类型，<code>long</code> 在处理速度上比 <code>BigDecimal</code> 快很多。</li><li><strong>容量限制</strong>：<code>long</code> 可以表示的最大值为 (2^{63}-1)，最小值为 (-2^{63})。这在大多数应用程序中已经足够，但在表示非常大的数或需要小数的计算中则不适用。</li><li><strong>不适合精确的小数运算</strong>：<code>long</code> 无法处理小数，如果需要代表金额中的小数部分（如厘），则需要自行管理这一部分。</li></ul><p><strong>所以，Long的适用场景是适合于不涉及小数计算的大整数运算，如某些计数应用或者金额以整数形式表示。比如我们的额度系统、积分系统等。</strong></p><hr><p>很多人会有疑惑，什么情况下会出现需要比分还小的单位呢？其实就是在很多需要运算的场景，比如说金融的费率、利率、服务费的费率等等，这些都是很小的，一般都是万分之几或者千分之几。而一旦有一个单位为元的金额和一个&quot;率&quot;相乘的时候，就会出现小于分的单位。</p><p>那有人说，遇到分我就直接四舍五入不就行了么，反正结算也是按照分结算的。这样做会有问题，我举个例子。</p><p>我一笔账单，有两笔订单，金额都是1元，存储的时候按照分存储，即100分，然后我的服务费费率是0.004。</p><p>如果是以分为单位，long存储和表示的话，那么两笔订单分开算费率的话：100*0.004 = 0.4 ，四舍五入 0， 两笔加在一起，收入的费率就是0分。</p><p>但是如说是以元为单位，bigdecimal存储和表示的话，那么两笔订单分开算费率的话：1*0.004 = 0.004 ， 两笔加在一起0.008，当我要结算的时候，再做四舍五入就是0.01元，即1分钱。</p><p>所以，<strong>因为long在计算和存储的过程中都会丢失掉小数部分，那就会导致每一次都被迫需要四舍五入。而decimal完全可以保留过程中的数据，再最终需要的时候做一次整体的四舍五入，这样结果就会更加精确！</strong></p><p>所以，如果你的应用需要处理小数点后的精确计算（如金融计算中常见的多位小数），则应选择 <code>BigDecimal</code>。</p><p>如果你的应用对性能要求极高，并且没有乘除类运算，不需要很小的精度时，那么使用 <code>long</code> 可能更合适。</p>`,76)),t(a,{style:{"background-color":"#FBDE28"}},{default:h(()=>i[0]||(i[0]=[s("总结来说，对于绝大多数涉及货币计算的应用，推荐使用 ")])),_:1}),i[2]||(i[2]=s("BigDecimal、 ，因为它提供了必要的精度和灵活性，尽管牺牲了一些性能。如果确定不需要处理小数，并且对执行速度有极端要求，使用long 可能更适合"))])}const m=e(d,[["render",r],["__file","BigDecimal.html.vue"]]),A=JSON.parse('{"path":"/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/BigDecimal.html","title":"BigDecimal","lang":"zh-CN","frontmatter":{"draw":null,"tags":[],"title":"BigDecimal","date created":"2024-07-16T00:00:00.000Z","date modified":"2024-11-12T00:00:00.000Z","description":"ROUND_HALF_UP 四舍五入 compareTo int、float、double 转 BigDecimal 不要直接用 new 方法，而是用 value of 典型回答 有区别，而且区别很大。 因为double是不精确的，所以使用一个不精确的数字来创建BigDecimal，得到的数字也是不精确的。如0.1这个数字，double只能表示他的近似...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/BigDecimal.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:title","content":"BigDecimal"}],["meta",{"property":"og:description","content":"ROUND_HALF_UP 四舍五入 compareTo int、float、double 转 BigDecimal 不要直接用 new 方法，而是用 value of 典型回答 有区别，而且区别很大。 因为double是不精确的，所以使用一个不精确的数字来创建BigDecimal，得到的数字也是不精确的。如0.1这个数字，double只能表示他的近似..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-27T12:47:07.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-27T12:47:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"BigDecimal\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-27T12:47:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"int、float、double 转 BigDecimal","slug":"int、float、double-转-bigdecimal","link":"#int、float、double-转-bigdecimal","children":[{"level":3,"title":"BigDecimal如何精确计数？","slug":"bigdecimal如何精确计数","link":"#bigdecimal如何精确计数","children":[]},{"level":3,"title":"BigDecimal(double)有什么问题","slug":"bigdecimal-double-有什么问题","link":"#bigdecimal-double-有什么问题","children":[]},{"level":3,"title":"使用BigDecimal(String)创建","slug":"使用bigdecimal-string-创建","link":"#使用bigdecimal-string-创建","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1732465042000,"updatedTime":1735303627000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":3}]},"readingTime":{"minutes":8.98,"words":2694},"filePathRelative":"2 第二大脑/1 节点/CS/编程语言/Java/数据类型/BigDecimal.md","localizedDate":"2024年11月25日","autoDesc":true}');export{m as comp,A as data};
