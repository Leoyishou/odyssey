import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,f as r,o as p}from"./app-DokaGNO4.js";const i={};function n(o,e){return p(),a("div",null,e[0]||(e[0]=[r('<h1 id="典型回答" tabindex="-1"><a class="header-anchor" href="#典型回答"><span>典型回答</span></a></h1><p>随着业务量的增长，为了提升整体系统的可用性、性能及可扩展性，很多大型互联网公司都会采用微服务架构，一次业务请求，一般要经过几个微服务调用才能完成，。</p><p>一次请求之间要经过很多的系统，那么如何追踪一次请求从头到尾的流程，就至关重要，这样可以帮我们做很好的链路分析，及问题定位。</p><p>在业内，有很多链路追踪的工具，如Google的dapper、twitter的zipkin、京东的hydra、大众点评的cat，以及开源的skywalking。建议大家看看Google的这篇论文，可以说它是分布式链路追踪的启蒙之作：<a href="https://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener noreferrer">https://bigbully.github.io/Dapper-translation/</a></p><p>不管是哪个实现，在我看来重点就是解决两个问题：</p><p>1、生成一个全局的traceId</p><p>2、把这个traceId传递下去</p><h3 id="生成traceid" tabindex="-1"><a class="header-anchor" href="#生成traceid"><span>生成TraceId</span></a></h3><p>想要追踪一个完成的链路，就需要有一个标识来标记这次调用链，业内把他叫做traceId，一般会在入口处生成一个全局唯一的traceId，比如说在HTTP的请求入口，在定时任务的调度入口等，生成一个traceId。</p><h3 id="传递traceid" tabindex="-1"><a class="header-anchor" href="#传递traceid"><span>传递TraceId</span></a></h3><p>在有了一个traceId之后，想要通过它把一次调用过程串联起来，那么就需要所有的系统间调用都得把他传递下去，这里面的调用包括了HTTP请求、RPC请求、MQ消息等，甚至还需要涉及到Redis、MySQL等等可能都需要进行传递。</p><p>所以，想要实现一个链路追踪，需要很多中间件一起配合才行，通常这个traceId会存放在RPC的请求头、HTTP的请求头、MQ消息的消息头中进行传递。</p><p>系统之间通过这种方式，那系统内部也是需要传递的，所以一般都是用ThreadLocal来实现的，在接收到请求后，会把这个traceId存储在ThreadLocal中，然后就能在当前线程中一直传递下去，并且在记录日志的时候取出来打印到日志中，在需要调远程的时候，取出来传递下去。</p><p>但是，如果有多线程怎么办呢？ThreadLocal咋传递呢，这就要用到TTL了：</p><p><a href="https://www.yuque.com/hollis666/vgoof0/fucuuyqoqv8rdkpr" target="_blank" rel="noopener noreferrer">✅有了InheritableThreadLocal为啥还需要TransmittableThreadLocal？</a></p><h1 id="扩展知识" tabindex="-1"><a class="header-anchor" href="#扩展知识"><span>扩展知识</span></a></h1><h2 id="span" tabindex="-1"><a class="header-anchor" href="#span"><span>Span</span></a></h2><p>前面提到了traceId，其实光有traceId还不够，trace帮我们把一次调用串联起来，但是一次调用在每一个系统上都干了什么，干了多久，成功还是失败，这些对我们来说也很重要，这些信息就被记录在span中。</p><p>通常一个完整的 Span 具有如下属性：</p><ul><li>Operation Name：描述了当前接口的行为语义，如具体的哪个接口，哪个URL地址。</li><li>SpanId/ParentSpanId：接口调用的层级标识，用于还原 Trace 内部的层次调用关系。</li><li>Start/FinishTime：接口调用的开始和结束时间，二者相减就是该次调用的耗时。</li><li>StatusCode：响应状态，标识当次调用是成功或失败。</li><li>Tags &amp; Events：调用附加信息</li></ul>',20)]))}const d=t(i,[["render",n],["__file","链路追踪.html.vue"]]),s=JSON.parse('{"path":"/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA.html","title":"典型回答","lang":"zh-CN","frontmatter":{"description":"典型回答 随着业务量的增长，为了提升整体系统的可用性、性能及可扩展性，很多大型互联网公司都会采用微服务架构，一次业务请求，一般要经过几个微服务调用才能完成，。 一次请求之间要经过很多的系统，那么如何追踪一次请求从头到尾的流程，就至关重要，这样可以帮我们做很好的链路分析，及问题定位。 在业内，有很多链路追踪的工具，如Google的dapper、twitt...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:title","content":"典型回答"}],["meta",{"property":"og:description","content":"典型回答 随着业务量的增长，为了提升整体系统的可用性、性能及可扩展性，很多大型互联网公司都会采用微服务架构，一次业务请求，一般要经过几个微服务调用才能完成，。 一次请求之间要经过很多的系统，那么如何追踪一次请求从头到尾的流程，就至关重要，这样可以帮我们做很好的链路分析，及问题定位。 在业内，有很多链路追踪的工具，如Google的dapper、twitt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-27T12:47:07.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-27T12:47:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"典型回答\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-27T12:47:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"生成TraceId","slug":"生成traceid","link":"#生成traceid","children":[]},{"level":3,"title":"传递TraceId","slug":"传递traceid","link":"#传递traceid","children":[]},{"level":2,"title":"Span","slug":"span","link":"#span","children":[]}],"git":{"createdTime":1733928507000,"updatedTime":1735303627000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":2}]},"readingTime":{"minutes":2.65,"words":796},"filePathRelative":"2 第二大脑/1 节点/CS/分布式系统/链路追踪.md","localizedDate":"2024年12月11日","autoDesc":true}');export{d as comp,s as data};
