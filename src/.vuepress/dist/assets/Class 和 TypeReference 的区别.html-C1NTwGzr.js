import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as o,d as r,e as l,g as n,f as p,r as i,o as c,b as m}from"./app-DokaGNO4.js";const C={};function d(E,e){const t=i("RouteLink");return c(),s("div",null,[o("p",null,[r(t,{to:"/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/TypeReference.html"},{default:l(()=>e[0]||(e[0]=[m("TypeReference")])),_:1})]),n(" more "),e[1]||(e[1]=p("<p><strong>Class</strong></p><p>Class 对象表示一种类型，它是 Java 反射机制的一部分。使用 Class 对象时，必须在编译时知道类型信息。适用于简单的类型反序列化。</p><p><strong>优点：</strong></p><ul><li>简单明了，适合常规类型的反序列化。</li><li>代码简洁，容易理解。</li></ul><p><strong>缺点：</strong></p><ul><li>不能处理泛型类型。对于复杂类型，不能直接使用 Class 对象进行反序列化。</li></ul><p>**</p><p>TypeReference 是 Jackson 提供的一个类，用于处理包含泛型的复杂类型。通过创建一个匿名子类来捕获泛型类型信息。</p><p><strong>优点：</strong></p><ul><li>能够处理复杂的泛型类型</li><li>提供更强的类型安全性。</li></ul><p><strong>缺点：</strong></p><ul><li>使用方式相对复杂，需要创建匿名子类来捕获类型信息。</li><li>代码稍微冗长，不如 Class 对象直观。</li></ul><p><strong>总结</strong></p><ul><li><strong>Class</strong>：用于反射操作，代表 Java 应用程序中的类或接口，可以在运行时获取类的详细信息和创建类的实例。</li><li><strong>TypeReference</strong>：用于泛型编程中捕获和存储泛型类型信息，尤其在需要在运行时保留泛型信息的场景下使用，例如在序列化和反序列化时。</li></ul>",14))])}const u=a(C,[["render",d],["__file","Class 和 TypeReference 的区别.html.vue"]]),f=JSON.parse('{"path":"/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Class%20%E5%92%8C%20TypeReference%20%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"Class 和 TypeReference 的区别","lang":"zh-CN","frontmatter":{"draw":null,"title":"Class 和 TypeReference 的区别","tags":[],"date created":"2024-06-06T00:00:00.000Z","date modified":"2024-11-12T00:00:00.000Z","description":"Class Class 对象表示一种类型，它是 Java 反射机制的一部分。使用 Class 对象时，必须在编译时知道类型信息。适用于简单的类型反序列化。 优点： 简单明了，适合常规类型的反序列化。 代码简洁，容易理解。 缺点： 不能处理泛型类型。对于复杂类型，不能直接使用 Class 对象进行反序列化。 ** TypeReference 是 Jack...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Class%20%E5%92%8C%20TypeReference%20%E7%9A%84%E5%8C%BA%E5%88%AB.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:title","content":"Class 和 TypeReference 的区别"}],["meta",{"property":"og:description","content":"Class Class 对象表示一种类型，它是 Java 反射机制的一部分。使用 Class 对象时，必须在编译时知道类型信息。适用于简单的类型反序列化。 优点： 简单明了，适合常规类型的反序列化。 代码简洁，容易理解。 缺点： 不能处理泛型类型。对于复杂类型，不能直接使用 Class 对象进行反序列化。 ** TypeReference 是 Jack..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-24T16:36:07.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-24T16:36:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Class 和 TypeReference 的区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-24T16:36:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1732465042000,"updatedTime":1732466167000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":3}]},"readingTime":{"minutes":1.09,"words":326},"filePathRelative":"2 第二大脑/1 节点/CS/编程语言/Java/Class 和 TypeReference 的区别.md","localizedDate":"2024年11月25日","autoDesc":true}');export{u as comp,f as data};
