import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,f as i,o as n}from"./app-DokaGNO4.js";const o={};function r(l,e){return n(),t("div",null,e[0]||(e[0]=[i('<h2 id="一、场景" tabindex="-1"><a class="header-anchor" href="#一、场景"><span>一、场景</span></a></h2><h3 id="酒店拼团需求中有一个复制报价的处理逻辑。需要复制-roomprice-对象" tabindex="-1"><a class="header-anchor" href="#酒店拼团需求中有一个复制报价的处理逻辑。需要复制-roomprice-对象"><span>酒店拼团需求中有一个复制报价的处理逻辑。需要复制 RoomPrice 对象</span></a></h3><ul><li><h2 id="该类嵌套及其复杂-如果靠代码调用的方式复制-需要手写的复制逻辑比较多-且当类发生变化后-新的开发人员不一定能注意到去补充深拷贝的代码逻辑。" tabindex="-1"><a class="header-anchor" href="#该类嵌套及其复杂-如果靠代码调用的方式复制-需要手写的复制逻辑比较多-且当类发生变化后-新的开发人员不一定能注意到去补充深拷贝的代码逻辑。"><span>该类嵌套及其复杂，如果靠代码调用的方式复制，需要手写的复制逻辑比较多，且当类发生变化后，新的开发人员不一定能注意到去补充深拷贝的代码逻辑。</span></a></h2></li><li><h2 id="通过序列化、反序列化的方式能较为方便地实现深拷贝-但是其底层依赖反射-反序列化时需要类提供默认的构造器。" tabindex="-1"><a class="header-anchor" href="#通过序列化、反序列化的方式能较为方便地实现深拷贝-但是其底层依赖反射-反序列化时需要类提供默认的构造器。"><span>通过序列化、反序列化的方式能较为方便地实现深拷贝，但是其底层依赖反射，反序列化时需要类提供默认的构造器。</span></a></h2><ul><li><h2 id="开发中初步采用了-jackson-序列化的方式-但是在类的更改中由于新增的-range-成员变量没有-ignore-导致报错。" tabindex="-1"><a class="header-anchor" href="#开发中初步采用了-jackson-序列化的方式-但是在类的更改中由于新增的-range-成员变量没有-ignore-导致报错。"><span>开发中初步采用了 Jackson 序列化的方式，但是在类的更改中由于新增的 Range 成员变量没有 Ignore，导致报错。</span></a></h2></li></ul></li></ul><h2 id="二、调研" tabindex="-1"><a class="header-anchor" href="#二、调研"><span>二、调研</span></a></h2><figure><img src="https://cdn.jsdelivr.net/gh/Leoyishou/imageHosting@main/img/20231128155243.png" alt="image.png|1000" tabindex="0" loading="lazy"><figcaption>image.png|1000</figcaption></figure><h2 id="三、目前结论" tabindex="-1"><a class="header-anchor" href="#三、目前结论"><span>三、目前结论</span></a></h2><h3 id="使用-kryo-无脑序列化-不需要特别注意什么" tabindex="-1"><a class="header-anchor" href="#使用-kryo-无脑序列化-不需要特别注意什么"><span>使用 Kryo，无脑序列化，不需要特别注意什么</span></a></h3><figure><img src="https://wiki.corp.qunar.com/download/attachments/788295317/image2023-11-6_15-46-57.png?version=1&amp;modificationDate=1699256817000&amp;api=v2" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://wiki.corp.qunar.com/download/attachments/788295317/image2023-11-6_15-53-44.png?version=1&amp;modificationDate=1699257225000&amp;api=v2" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="四、思考" tabindex="-1"><a class="header-anchor" href="#四、思考"><span>四、思考</span></a></h2><h3 id="_4-1-非反射、递归手写-getset-的方式" tabindex="-1"><a class="header-anchor" href="#_4-1-非反射、递归手写-getset-的方式"><span>4.1 非反射、递归手写 getset 的方式</span></a></h3><p>一、clone</p><ol><li>需要递归地将整个 Object Tree 的所有类 <code>implements Cloneable</code>, 用深拷贝的方式重写 clone() 方法</li><li>effective java 不建议用 clone <ol><li>直接调 super.clone(),只能完成浅拷贝。</li><li>要想深拷贝需要自己补充实现，但是这样的话递归关系嵌在了 object tree 上的每个 clone 方法里，容易受到 final 等修饰符的影响。自己实现每个地方的</li></ol></li></ol><p>二、写一个拷贝构造器</p><ol><li>public MyClass(MyClass other) 自己实现方法，对于不可变对象或原始类型，直接复制其值即可；对于可变对象或数组，可能需要递归复制每个元素或子对象。</li></ol><p>三、写一个拷贝工厂 public static MyClass newInstance(MyClass other)</p><p>总结：</p><ol><li>**<code>Cloneable</code>**接口只能保证 clone 方法能用，但是不能约束 clone 的质量。clone() 将复制办法存在每个类中，不能保证每处的实现都满足深拷贝，比如 HashMap</li><li>构造器或者工厂的方式，在一个地方统一约束递归关系</li></ol><h3 id="_4-2-反射、序列反序列化的方式" tabindex="-1"><a class="header-anchor" href="#_4-2-反射、序列反序列化的方式"><span>4.2 反射、序列反序列化的方式</span></a></h3><p>考虑的点：1. 空间、空间影响传输成本 2.时间 3.传输安全 4.一些类反序列化会出问题</p><p>在我们这个场景下，没有传输这件事，所以似乎只需要考虑时间的问题；range、pair 的问题</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><p><a href="https://github.com/EsotericSoftware/kryo#without-maven" target="_blank" rel="noopener noreferrer">https://github.com/EsotericSoftware/kryo#without-maven</a></p><figure><img src="https://wiki.corp.qunar.com/download/attachments/788295317/image2023-11-4_0-15-52.png?version=1&amp;modificationDate=1699028152000&amp;api=v2" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛的使用。</p>',26)]))}const p=a(o,[["render",r],["__file","序列化与深拷贝.html.vue"]]),h=JSON.parse('{"path":"/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html","title":"序列化与深拷贝","lang":"zh-CN","frontmatter":{"draw":null,"tags":[],"title":"序列化与深拷贝","date created":"2023-11-28T00:00:00.000Z","date modified":"2024-11-12T00:00:00.000Z","description":"一、场景 酒店拼团需求中有一个复制报价的处理逻辑。需要复制 RoomPrice 对象 该类嵌套及其复杂，如果靠代码调用的方式复制，需要手写的复制逻辑比较多，且当类发生变化后，新的开发人员不一定能注意到去补充深拷贝的代码逻辑。 通过序列化、反序列化的方式能较为方便地实现深拷贝，但是其底层依赖反射，反序列化时需要类提供默认的构造器。 开发中初步采用了 Ja...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:title","content":"序列化与深拷贝"}],["meta",{"property":"og:description","content":"一、场景 酒店拼团需求中有一个复制报价的处理逻辑。需要复制 RoomPrice 对象 该类嵌套及其复杂，如果靠代码调用的方式复制，需要手写的复制逻辑比较多，且当类发生变化后，新的开发人员不一定能注意到去补充深拷贝的代码逻辑。 通过序列化、反序列化的方式能较为方便地实现深拷贝，但是其底层依赖反射，反序列化时需要类提供默认的构造器。 开发中初步采用了 Ja..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/Leoyishou/imageHosting@main/img/20231128155243.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-24T16:17:22.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-24T16:17:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"序列化与深拷贝\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/Leoyishou/imageHosting@main/img/20231128155243.png\\",\\"https://wiki.corp.qunar.com/download/attachments/788295317/image2023-11-6_15-46-57.png?version=1&modificationDate=1699256817000&api=v2\\",\\"https://wiki.corp.qunar.com/download/attachments/788295317/image2023-11-6_15-53-44.png?version=1&modificationDate=1699257225000&api=v2\\",\\"https://wiki.corp.qunar.com/download/attachments/788295317/image2023-11-4_0-15-52.png?version=1&modificationDate=1699028152000&api=v2\\"],\\"dateModified\\":\\"2024-11-24T16:17:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、场景","slug":"一、场景","link":"#一、场景","children":[{"level":3,"title":"酒店拼团需求中有一个复制报价的处理逻辑。需要复制 RoomPrice 对象","slug":"酒店拼团需求中有一个复制报价的处理逻辑。需要复制-roomprice-对象","link":"#酒店拼团需求中有一个复制报价的处理逻辑。需要复制-roomprice-对象","children":[]}]},{"level":2,"title":"二、调研","slug":"二、调研","link":"#二、调研","children":[]},{"level":2,"title":"三、目前结论","slug":"三、目前结论","link":"#三、目前结论","children":[{"level":3,"title":"使用 Kryo，无脑序列化，不需要特别注意什么","slug":"使用-kryo-无脑序列化-不需要特别注意什么","link":"#使用-kryo-无脑序列化-不需要特别注意什么","children":[]}]},{"level":2,"title":"四、思考","slug":"四、思考","link":"#四、思考","children":[{"level":3,"title":"4.1 非反射、递归手写 getset 的方式","slug":"_4-1-非反射、递归手写-getset-的方式","link":"#_4-1-非反射、递归手写-getset-的方式","children":[]},{"level":3,"title":"4.2 反射、序列反序列化的方式","slug":"_4-2-反射、序列反序列化的方式","link":"#_4-2-反射、序列反序列化的方式","children":[]}]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}],"git":{"createdTime":1732465042000,"updatedTime":1732465042000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":1}]},"readingTime":{"minutes":2.46,"words":738},"filePathRelative":"2 第二大脑/1 节点/CS/软件工程/后端/序列化与深拷贝.md","localizedDate":"2024年11月25日","autoDesc":true}');export{p as comp,h as data};
