import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,f as a,o as l}from"./app-DokaGNO4.js";const r={};function n(t,i){return l(),e("div",null,i[0]||(i[0]=[a(`<p>先来回顾一下这个 <strong>backtrace</strong> 函数做了什么，再解释它为什么这样写——主要和 <strong>RISC-V 的函数栈帧布局</strong>、<strong>xv6 内核栈大小</strong> 以及 <strong>如何检测栈回溯的终点</strong> 有关。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> backtrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  uint64 cur_fp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> r_fp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       // 1. 获取当前函数的帧指针 (s0)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cur_fp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> PGROUNDDOWN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cur_fp))</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 2. 检查是否超过当前栈页的边界</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%p</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(uint64 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)(cur_fp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 3. 打印返回地址 (ra)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    cur_fp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(uint64 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)(cur_fp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          // 4. 更新 fp 为上层函数的帧指针</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们分步骤看其中的关键点。</p><hr><h2 id="_1-risc-v-函数栈帧布局" tabindex="-1"><a class="header-anchor" href="#_1-risc-v-函数栈帧布局"><span>1. RISC-V 函数栈帧布局</span></a></h2><p>按照 GCC 在 RISC-V 平台上的调用约定，每个函数的大致栈帧 (frame) 结构如下（从高地址到低地址）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>                high addresses</span></span>
<span class="line"><span>                +-------------------+</span></span>
<span class="line"><span>                |   ...            |  (可能还有函数的局部变量)</span></span>
<span class="line"><span> (frame base) -&gt;+-------------------+</span></span>
<span class="line"><span>       s0(fp) -&gt;|  old s0 (上一个函数的帧指针)  |  (存放在 fp-16)</span></span>
<span class="line"><span>                |  return address (ra)         |  (存放在 fp-8)</span></span>
<span class="line"><span>                +-------------------+</span></span>
<span class="line"><span>                |   ...            |</span></span>
<span class="line"><span>                low addresses</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>s0 (fp)</strong>：当前函数的帧指针寄存器。</li><li><strong>(fp - 8)</strong>：存放函数的返回地址 (ra)，用来在函数结束时跳回调用者。</li><li><strong>(fp - 16)</strong>：存放上一层函数的帧指针 (old s0)，用来回溯调用栈。</li></ul><p>在 xv6 中，为了做 backtrace，就需要：</p><ol><li>读出当前函数的帧指针。</li><li>从 <code>(fp - 8)</code> 拿到当前函数保存的返回地址 (ra)，打印它。</li><li>再从 <code>(fp - 16)</code> 拿到前一个函数的帧指针，继续往上层函数回溯。</li></ol><hr><h2 id="_2-为什么用-while-cur-fp-pgrounddown-cur-fp-判断结束" tabindex="-1"><a class="header-anchor" href="#_2-为什么用-while-cur-fp-pgrounddown-cur-fp-判断结束"><span>2. 为什么用 <code>while (cur_fp != PGROUNDDOWN(cur_fp))</code> 判断结束？</span></a></h2><p>xv6 的内核线程栈大小是一页(4KB)，是 <strong>页对齐</strong> 的。也就是说，每个内核线程有一页专门做它的内核栈，起始地址是 <code>PGROUNDDOWN(stack_top)</code>，结束地址是 <code>PGROUNDUP(stack_top)</code>。</p><p>当我们回溯栈帧时，一旦 <code>cur_fp</code>（当前帧指针）<strong>走到或跨过这页的边界</strong>，就说明已经超出了这条内核栈的范围，再继续回溯就会访问到不属于该栈或者无效的内存区域，可能会崩溃或读到垃圾数据。</p><ul><li><code>PGROUNDDOWN(x)</code>：把地址 <code>x</code> 下舍到所在的页边界。例如，如果 x 在 0xABCDEF，那么它对应页边界可能是 0xABCDE000(假设 4KB 一页)。</li><li>所以 <code>cur_fp != PGROUNDDOWN(cur_fp)</code> 这个判断相当于 “<strong>只要 <code>cur_fp</code> 还不是等于它所在页的起始地址，就继续回溯</strong>”。若相等，说明我们到底了，必须停下来。</li></ul><p>也有人会采用其他判断方式，比如“只要 <code>cur_fp</code> 落在 [stack_bottom, stack_top] 之间就继续”，原理类似，都是为了避免访问越界。</p><hr><h2 id="_3-打印返回地址并回溯到上一帧" tabindex="-1"><a class="header-anchor" href="#_3-打印返回地址并回溯到上一帧"><span>3. 打印返回地址并回溯到上一帧</span></a></h2><p>在循环里：</p><ol><li><code>*(uint64 *)(cur_fp - 8)</code>：这正是栈帧中的返回地址 ra。</li><li><code>cur_fp = *(uint64 *)(cur_fp - 16)</code>：将当前帧指针更新为“上一个函数”的帧指针 old s0。</li></ol><p>周而复始，把每一层函数的返回地址都打印出来，就得到了「调用栈回溯」的地址列表。</p><p>在 GDB 里，你看到的 “backtrace” 命令做了类似的事情，只不过它还会把地址映射到具体的函数名、行号（通过符号表 / 调试信息）。</p><hr><h3 id="总结一下" tabindex="-1"><a class="header-anchor" href="#总结一下"><span>总结一下</span></a></h3><ul><li><strong>帧指针 (fp = s0)</strong>：RISC-V / GCC 的函数约定把老的 fp 和 ra 分别存在 <code>fp-16</code>、<code>fp-8</code>。</li><li><strong>循环回溯</strong>：从当前帧指针往回一个个找老的 fp，并打印 ra。</li><li><strong>终止条件</strong>：在 xv6 里，每个内核栈是一页大小，一旦 <code>cur_fp</code> 减小到等于该页的下边界(<code>PGROUNDDOWN</code>)，说明已经退到栈底了，必须停止。否则就越界了。</li></ul><p>所以，这就是为什么 backtrace 会以这种形式实现：<strong>因为栈帧布局固定</strong>，并且 <strong>xv6 每条内核栈只有一页</strong>，故用这样的简单循环即可实现堆栈回溯。</p><h2 id="为什么需要-alarm-打断" tabindex="-1"><a class="header-anchor" href="#为什么需要-alarm-打断"><span>为什么需要 alarm 打断</span></a></h2><ul><li><strong>操作系统要“分配时间”给大家</strong><br> 你的电脑可能同时要运行很多程序，比如游戏、浏览器、音乐播放器。要是其中一个程序一直霸占着 CPU，不让出时间，其他程序就没法顺利工作。</li><li><strong>时钟“叮”一下，是给操作系统发个信号</strong><br> 操作系统设置了一个“小闹钟”（硬件定时器），让它定时“叮”一下，提醒操作系统：“诶，现在过了一个时间片了，你要不要换个程序来跑啊？”</li><li><strong>被时钟“打断”，进入内核</strong><br> 当这个小闹钟响了，CPU 立刻暂停正在运行的用户程序，跳到内核里运行一段“特殊程序”（时钟中断处理例程）。这个程序会决定是否要让当前进程再继续跑，还是切换到别的进程去跑，或者做一些别的周期性工作（比如维护系统时间等）。</li><li><strong>然后再回去</strong><br> 处理完以后，操作系统又把 CPU 切回给某个进程（可能是原来那个，也可能是别的）。于是，用户程序继续从刚才被打断的地方继续运行。 <strong>防止重复 alarm</strong>：处理闹钟函数时，不要再被闹钟打断，否则会乱套。</li></ul><p>下面给出一个整体的思路指南，帮助理解和实现这个 Lab 的关键步骤和原理。各个部分互相关联，需要在阅读 xv6 相关源码 (trap.c、trampoline.S、syscall.c、proc.c 等) 和 Lab 文档的基础上逐步实现。</p><hr><h2 id="_1-理解-risc-v-汇编与栈帧" tabindex="-1"><a class="header-anchor" href="#_1-理解-risc-v-汇编与栈帧"><span>1. 理解 RISC-V 汇编与栈帧</span></a></h2><p>Lab 的第一部分，先让你去阅读并理解一些 RISC-V 汇编代码，以及函数调用过程中的寄存器使用、压栈和回栈逻辑。这为后面做 backtrace（回溯调用栈）和手动保存/恢复寄存器（alarm 机制）做准备。</p><ul><li><p><strong>函数参数与返回值</strong><br> RISC-V 调用约定中，a0~a7 作为函数参数和返回值寄存器；ra (return address) 用来存储返回地址；s0 (fp/frame pointer) 用来存储当前函数的帧指针等。</p></li><li><p><strong>函数调用的 inlining</strong><br> C 编译器有时会把一些小函数“内联”到调用处，导致在汇编里看不到对应的 <code>call</code> 指令。需要仔细查看生成的汇编(<code>.asm</code>)以确定哪些函数被真正调用、哪些被内联。</p></li><li><p><strong>小端与大端</strong><br> RISC-V 是小端序 (little-endian)，这会影响到像 <code>0x00646c72</code> 这样的数在内存中的存储顺序，以及在 printf 时如何被解释成字符串。如果切换到大端序，需要调整字节顺序。</p></li></ul><hr><h2 id="_2-backtrace-回溯调用栈" tabindex="-1"><a class="header-anchor" href="#_2-backtrace-回溯调用栈"><span>2. Backtrace（回溯调用栈）</span></a></h2><p>在 xv6 中，如果发生错误或想要调试，就希望能打印出内核函数的调用栈。为了拿到调用栈上的各个返回地址，需要：</p><ol><li><p><strong>了解栈帧结构</strong></p><ul><li>每个函数在进入时，会把前一个函数的帧指针 (s0) 和返回地址 (ra) 等压栈，然后更新 s0，构造新的栈帧。</li><li>对于 RISC-V/GCC，<code>s0</code> (fp) 指向当前栈帧的底部。 <ul><li><code>(fp - 8)</code> 处存返回地址 <code>ra</code>；</li><li><code>(fp - 16)</code> 处存老的 fp；</li><li>然后再往下是函数的局部变量区域等。</li></ul></li></ul></li><li><p><strong>在内核里实现 <code>backtrace()</code> 函数</strong></p><ul><li>可以在 <code>kernel/printf.c</code> 添加一个函数 <code>backtrace()</code>，利用内联汇编或者写一个 <code>r_fp()</code> 读取当前 <code>s0</code> (即当前帧指针)。</li><li>循环地根据内存结构，依次找出保存的返回地址、前一个帧指针，再往上回溯，直到超过该内核栈所在的地址区间 (例如用 <code>PGROUNDDOWN(fp)</code> 和 <code>PGROUNDUP(fp)</code> 来确定栈的边界)。</li><li>每找到一个返回地址，就用 <code>printf</code> 打印出来。</li></ul></li><li><p><strong>调用 backtrace()</strong></p><ul><li>在 <code>sys_sleep()</code> 或者在 <code>panic()</code> 等函数中调用 <code>backtrace()</code>，便可以观察到函数调用栈。</li></ul></li></ol><hr><h2 id="_3-alarm-用户态定时-中断-陷入处理" tabindex="-1"><a class="header-anchor" href="#_3-alarm-用户态定时-中断-陷入处理"><span>3. Alarm (用户态定时“中断”/陷入处理)</span></a></h2><p>这一部分让你在用户空间里模拟出一个“信号”或“定时器”处理机制：进程在用户态运行一段时间后，被时钟中断打断，进入内核，然后从内核“返回”到用户态时，跳转执行一个用户态的“handler”函数；用户态“handler”执行完后，再返回原来的代码继续执行。</p><h3 id="_3-1-新增系统调用" tabindex="-1"><a class="header-anchor" href="#_3-1-新增系统调用"><span>3.1 新增系统调用</span></a></h3><ul><li><p><strong><code>sigalarm(int ticks, void (*handler)())</code></strong><br> 用来设置：</p><ol><li><code>interval</code>：进程每运行 <code>ticks</code> 个时钟周期后，就触发一次“定时报警”。</li><li><code>handler</code>：报警时要执行的用户态函数。</li></ol><p>如果传入 <code>(0, 0)</code>，表示取消报警。</p></li><li><p><strong><code>sigreturn()</code></strong><br> 用户态 <code>handler</code> 执行完后，要通过 <code>sigreturn()</code> 返回原来的执行现场，继续执行被打断的用户程序。</p></li></ul><p>要做的事：</p><ol><li>在 <code>user/user.h</code> 中声明函数原型。</li><li>在 <code>kernel/syscall.c</code> 和 <code>kernel/syscall.h</code> 里添加对应的 syscall 编号和分发逻辑。</li><li>在 <code>kernel/sysproc.c</code> 中实现 <code>sys_sigalarm()</code> 和 <code>sys_sigreturn()</code> 函数体。</li><li>在 <code>proc.h</code> 的进程结构 <code>struct proc</code> 里加几个字段，用来记录： <ul><li><code>alarm_interval</code>：<code>sigalarm(ticks, handler)</code> 传入的间隔。</li><li><code>alarm_handler</code>：指向用户传入的函数地址。</li><li><code>alarm_ticksleft</code>：距离下次触发 alarm 还剩多少 tick。</li><li>以及防止递归重入的标志位，如 <code>alarm_in_handler</code> 表明当前是否已经在执行 alarm handler。</li></ul></li></ol><h3 id="_3-2-在内核捕获时钟中断并切换到用户-handler" tabindex="-1"><a class="header-anchor" href="#_3-2-在内核捕获时钟中断并切换到用户-handler"><span>3.2 在内核捕获时钟中断并切换到用户 handler</span></a></h3><p>时钟中断发生在 <code>trap.c</code> 的 <code>usertrap()</code> 里，每次时钟中断 (<code>which_dev == 2</code>) 都会让当前正在运行的进程 <code>p-&gt;alarm_ticksleft</code> 自减。若减到 0，表示需要调用用户态 alarm handler 了：</p><ol><li><p><strong>判断是否已经在 handler 里</strong></p><ul><li>如果已经在 handler 里了，就不要再进，以防止在 handler 里又被时钟打断，再次进 handler，陷入无限递归。</li></ul></li><li><p><strong>保存现场</strong></p><ul><li>这里的“现场”包括所有通用寄存器（a0<s>a7、t0</s>t6、s0~s11、ra、sp 等）、原始的程序计数器 (PC) 等。</li><li>xv6 提供了 <code>struct trapframe</code> 记录用户态大部分寄存器，但你需要确保把“足以恢复”的信息都保存下来。尤其是 PC、ra、sp、s0 等对后面恢复很关键的寄存器。</li><li>将这些寄存器保存到 <code>proc</code> 里专门为 alarm 准备的保存区，比如可以再额外加一个 <code>struct trapframe alarm_trapframe</code>，或者把需要保存的字段先缓存。</li></ul></li><li><p><strong>修改 trapframe</strong></p><ul><li>把 <code>trapframe-&gt;epc</code>（即下一条将要执行的指令）改为 <code>alarm_handler</code> 的地址，这样在 <code>usertrap()</code> 返回用户态时，会从 <code>alarm_handler</code> 的入口执行。</li><li>同时可以把 <code>alarm_ticksleft</code> 重置成 <code>alarm_interval</code>，这样过了 interval 之后又会触发下一次 alarm。</li></ul></li></ol><h3 id="_3-3-sigreturn-恢复现场" tabindex="-1"><a class="header-anchor" href="#_3-3-sigreturn-恢复现场"><span>3.3 <code>sigreturn</code> 恢复现场</span></a></h3><p>在用户态的 <code>handler</code> 函数执行完毕，会调用 <code>sigreturn()</code>。进入内核的 <code>sys_sigreturn()</code> 后，你需要：</p><ol><li><strong>从 <code>proc</code> 中取出先前保存好的现场信息</strong><ul><li>将保存的所有寄存器值、PC 等还原到当前进程的 <code>trapframe</code>。</li></ul></li><li><strong>将 <code>alarm_in_handler</code> 标志位清 0</strong>，允许下次 alarm 发生。</li></ol><p>这样在下一次 <code>usertrap()</code> 返回用户态时，就能回到原本被打断的指令处继续执行，好像什么都没发生过一样。</p><hr><h2 id="_4-关键注意点" tabindex="-1"><a class="header-anchor" href="#_4-关键注意点"><span>4. 关键注意点</span></a></h2><ul><li><strong>防止重复进入 handler</strong><br> 如果 handler 还没执行完就又发生时钟中断，要么忽略这次中断，要么累加计数但不调用新的 handler，以免出现严重错误或无限递归。</li><li><strong>保存/恢复足够的寄存器</strong><br> 如果漏保存某些寄存器值，handler 返回后用户程序可能会出现奇怪的 bug。</li><li><strong>测试</strong><ul><li><code>alarmtest</code>：包括了 test0 / test1 / test2 等，逐渐会检查是不是能正确打印 <code>&quot;alarm!&quot;</code>、能否多次周期性地调用 handler、能否在 handler 中嵌套等。</li><li><code>usertests</code>：检查 xv6 全部其他功能是否被破坏。</li></ul></li></ul><hr><h2 id="_5-提交与打包" tabindex="-1"><a class="header-anchor" href="#_5-提交与打包"><span>5. 提交与打包</span></a></h2><ul><li><code>make grade</code> 确保本 lab 所有测试都能通过。</li><li><code>make handin</code> 根据课程网站要求，上传你的提交。</li></ul><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><strong>实现思路简要概括</strong>：</p><ol><li><strong>前置准备</strong>：理解 RISC-V 调用约定和栈帧结构。</li><li><strong>Backtrace</strong>：利用 s0(fp) 链式回溯，每个函数的返回地址保存在 <code>fp-8</code>。循环向上直到越过当前栈的边界停止。</li><li><strong>Alarm</strong>： <ul><li>新增 <code>sigalarm()</code>/<code>sigreturn()</code> 系统调用，扩展进程结构存储 alarm 的状态 (interval / handler / 是否在执行 handler / 剩余 ticks / 保存现场)。</li><li>时钟中断时，在 <code>usertrap()</code> 判断是否到期执行用户态 handler；执行前保存寄存器现场，修改返回的 PC 指向 handler；handler 结束后用 <code>sigreturn()</code> 恢复原先被打断的上下文。</li><li>重复此过程，实现周期性“闹钟”功能。</li></ul></li></ol><p>整体比较考验对系统调用流程、RISC-V trap 机制、栈帧布局和寄存器保存的理解。只要理清 trap→kernel→修改 trapframe→返回 user space 以及再从 user space→sigreturn→kernel→恢复 trapframe 这一来一回的过程，并 carefully 处理好寄存器保存/恢复，就能顺利完成。祝一切顺利!</p>`,62)]))}const o=s(r,[["render",n],["__file","Lab4 traps.html.vue"]]),p=JSON.parse('{"path":"/1%20%E4%B8%80%E5%88%87%E7%9A%86%E9%A1%B9%E7%9B%AE/Q2%EF%BC%9A%E5%81%9ACS%E7%9A%84%E7%BB%8F%E5%85%B8lab/MIT%206.828/lab/Lab4%20traps.html","title":"","lang":"zh-CN","frontmatter":{"description":"先来回顾一下这个 backtrace 函数做了什么，再解释它为什么这样写——主要和 RISC-V 的函数栈帧布局、xv6 内核栈大小 以及 如何检测栈回溯的终点 有关。 让我们分步骤看其中的关键点。 1. RISC-V 函数栈帧布局 按照 GCC 在 RISC-V 平台上的调用约定，每个函数的大致栈帧 (frame) 结构如下（从高地址到低地址）： s...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/1%20%E4%B8%80%E5%88%87%E7%9A%86%E9%A1%B9%E7%9B%AE/Q2%EF%BC%9A%E5%81%9ACS%E7%9A%84%E7%BB%8F%E5%85%B8lab/MIT%206.828/lab/Lab4%20traps.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:description","content":"先来回顾一下这个 backtrace 函数做了什么，再解释它为什么这样写——主要和 RISC-V 的函数栈帧布局、xv6 内核栈大小 以及 如何检测栈回溯的终点 有关。 让我们分步骤看其中的关键点。 1. RISC-V 函数栈帧布局 按照 GCC 在 RISC-V 平台上的调用约定，每个函数的大致栈帧 (frame) 结构如下（从高地址到低地址）： s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-27T06:52:25.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-27T06:52:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-27T06:52:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1. RISC-V 函数栈帧布局","slug":"_1-risc-v-函数栈帧布局","link":"#_1-risc-v-函数栈帧布局","children":[]},{"level":2,"title":"2. 为什么用 while (cur_fp != PGROUNDDOWN(cur_fp)) 判断结束？","slug":"_2-为什么用-while-cur-fp-pgrounddown-cur-fp-判断结束","link":"#_2-为什么用-while-cur-fp-pgrounddown-cur-fp-判断结束","children":[]},{"level":2,"title":"3. 打印返回地址并回溯到上一帧","slug":"_3-打印返回地址并回溯到上一帧","link":"#_3-打印返回地址并回溯到上一帧","children":[{"level":3,"title":"总结一下","slug":"总结一下","link":"#总结一下","children":[]}]},{"level":2,"title":"为什么需要 alarm 打断","slug":"为什么需要-alarm-打断","link":"#为什么需要-alarm-打断","children":[]},{"level":2,"title":"1. 理解 RISC-V 汇编与栈帧","slug":"_1-理解-risc-v-汇编与栈帧","link":"#_1-理解-risc-v-汇编与栈帧","children":[]},{"level":2,"title":"2. Backtrace（回溯调用栈）","slug":"_2-backtrace-回溯调用栈","link":"#_2-backtrace-回溯调用栈","children":[]},{"level":2,"title":"3. Alarm (用户态定时“中断”/陷入处理)","slug":"_3-alarm-用户态定时-中断-陷入处理","link":"#_3-alarm-用户态定时-中断-陷入处理","children":[{"level":3,"title":"3.1 新增系统调用","slug":"_3-1-新增系统调用","link":"#_3-1-新增系统调用","children":[]},{"level":3,"title":"3.2 在内核捕获时钟中断并切换到用户 handler","slug":"_3-2-在内核捕获时钟中断并切换到用户-handler","link":"#_3-2-在内核捕获时钟中断并切换到用户-handler","children":[]},{"level":3,"title":"3.3 sigreturn 恢复现场","slug":"_3-3-sigreturn-恢复现场","link":"#_3-3-sigreturn-恢复现场","children":[]}]},{"level":2,"title":"4. 关键注意点","slug":"_4-关键注意点","link":"#_4-关键注意点","children":[]},{"level":2,"title":"5. 提交与打包","slug":"_5-提交与打包","link":"#_5-提交与打包","children":[{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1735282345000,"updatedTime":1735282345000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":1}]},"readingTime":{"minutes":10.47,"words":3140},"filePathRelative":"1 一切皆项目/Q2：做CS的经典lab/MIT 6.828/lab/Lab4 traps.md","localizedDate":"2024年12月27日","autoDesc":true}');export{o as comp,p as data};
