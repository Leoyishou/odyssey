import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,f as r,o}from"./app-DokaGNO4.js";const i={};function s(l,t){return o(),e("div",null,t[0]||(t[0]=[r('<p>大 key 治理 <a href="%E7%A7%92%E5%86%99%E5%9B%9E">秒写回</a></p><p>在 Redis 中出现大 Key（即某个键所存储的数据过于庞大、数据量特别大）会引发一系列问题，例如内存占用过大、网络传输成本过高、阻塞 Redis 主线程导致延迟飙升、数据迁移和扩容困难等。为了更好地治理和优化大 Key，通常需要从数据模型设计、数据分片、访问模式优化、持久化策略与监控告警等多方面入手。以下是较为系统的思路和实践方法：</p><ol><li><p><strong>数据模型优化与设计层面</strong>：</p><ul><li><strong>提前预防大 Key 的产生</strong>：在业务早期就充分了解数据访问和存储需求，防止将过多数据压缩在单一键下。</li><li><strong>数据分片 (Sharding)</strong>：将一个大键的存储数据合理拆分为多个较小的键。例如对一个存储数百万条数据的 List，可以按照一定的 hash 或索引规则切分为多个独立的 list key。</li><li><strong>使用更合适的数据结构</strong>：Redis 提供多种数据结构（String、List、Hash、Set、ZSet、HyperLogLog、Stream等），根据数据特征选取合适的数据结构。例如，如果你存放的是类似用户信息键值对，Hash结构的内存利用率更高且访问粒度更细，有利于在后续做拆分。</li></ul></li><li><p><strong>分层与索引化</strong>：</p><ul><li><strong>层次化存储</strong>：将原本整合在一个键的数据分为多层结构。上层是一个聚合索引键（比如一个 Hash 表），下层是多个更小的子键，每个子键对应一部分数据。通过索引键来管理和快速定位下层子键。</li><li><strong>分批加载与懒加载</strong>：在访问数据时，只在需要时访问相应的子键数据，而不是一口气读取整个大 Key，从而降低单次访问延迟与内存峰值。</li></ul></li><li><p><strong>数据压缩与序列化策略</strong>：</p><ul><li><strong>数据压缩</strong>：在存储较大文本或重复模式较多的数据时，可选择对数据进行压缩后存入 Redis（如 gz、lz4 等方式），虽然 Redis 本身不直接提供压缩功能，但可通过应用侧在 set/get 时对数据进行压缩与解压缩处理。</li><li><strong>轻量化存储</strong>：若数据是较大对象序列化结果，则可选择更高效的序列化协议（如 MsgPack、Protobuf）减少数据体积。</li></ul></li><li><p><strong>操作粒度与访问模式优化</strong>：</p><ul><li><strong>谨慎使用 Keys 操作</strong>：不要使用 <code>KEYS</code> 命令来扫描过大键空间，改用 <code>SCAN</code> 避免阻塞。</li><li><strong>分步读取（Chunking）</strong>：对大数据进行分段读写，每次只处理一部分数据，减少阻塞。</li><li><strong>异步删除/逐步淘汰</strong>：在删除大 Key 时采用 <code>UNLINK</code>（4.0+） 而不是 <code>DEL</code>，以在后台线程异步回收内存，避免阻塞主线程。</li></ul></li><li><p><strong>监控与告警</strong>：</p><ul><li><strong>大 Key 监控</strong>：使用 Redis 内置的 <code>MEMORY USAGE</code> 命令或外部监控工具（如 RedisInsight、grafana+prometheus 方案）对 Key 大小进行定期采样检查。发现超大 Key 时及时预警和处理。</li><li><strong>内存上限控制</strong>：合理设置 <code>maxmemory</code> 和淘汰策略，并对特定业务键进行定期巡检，避免 Key 体量无节制增长。</li></ul></li><li><p><strong>架构与运维层面</strong>：</p><ul><li><strong>分布式架构与分库分表</strong>：对于超大数据集，可以使用 Redis Cluster，将数据水平拆分到多个分片中，降低单节点大 Key 的风险。</li><li><strong>冷热分离</strong>：将不常访问的数据从 Redis 中移出，存入更廉价、更适合长久存储的系统（如 MySQL 或 Cassandra），Redis 只保留热点数据。</li><li><strong>定期清理与归档</strong>：对不再需要实时查询的历史数据，定期清理出 Redis，以免形成大 Key。</li></ul></li><li><p><strong>通过中间层或代理进行治理</strong>：</p><ul><li><strong>应用侧缓存抽象层</strong>：在应用中加一层缓存访问逻辑，对即将写入 Redis 的数据进行拆分和规则化存储，从源头杜绝大 Key。</li><li><strong>数据治理策略与自动化</strong>：建立自动检测大 Key 的运维脚本，一旦发现异常键，自动触发拆分、迁移或清理操作。</li></ul></li></ol><p>综合而言，对 Redis 大 Key 的治理核心思想在于 <strong>事前设计+事中监控+事后优化</strong>，具体手段包括数据结构和存储模式的优化、分片与索引技术、访问模式微调、合适的删除与压缩策略，以及通过增强监控与报警来实现闭环治理。这些手段的有机结合将显著降低由于大 Key 导致的 Redis 性能与可用性问题。</p><table><thead><tr><th>平均adr区间</th><th>0</th><th>(0-5%)</th><th>(5%-10%)</th><th>(10%-15%)</th><th>(15%-20%)</th><th>(20%-30%)</th><th>(30%-50%)</th><th>(&gt;50%)</th></tr></thead><tbody><tr><td>0-99</td><td>17.94%</td><td>13.55%</td><td>20.85%</td><td>17.94%</td><td>11.57%</td><td>10.06%</td><td>5.40%</td><td>2.68%</td></tr><tr><td>100-199</td><td>5.90%</td><td>9.61%</td><td>23.49%</td><td>23.03%</td><td>16.83%</td><td>15.60%</td><td>4.22%</td><td>1.32%</td></tr><tr><td>200-299</td><td>2.12%</td><td>4.16%</td><td>18.10%</td><td>25.03%</td><td>23.63%</td><td>22.09%</td><td>8.22%</td><td>0.96%</td></tr><tr><td>300-399</td><td>1.49%</td><td>2.44%</td><td>14.16%</td><td>25.25%</td><td>25.03%</td><td>27.10%</td><td>14.86%</td><td>1.48%</td></tr><tr><td>400-499</td><td>1.62%</td><td>1.79%</td><td>12.85%</td><td>24.57%</td><td>24.54%</td><td>27.76%</td><td>17.02%</td><td>2.84%</td></tr><tr><td>500-599</td><td>1.46%</td><td>1.64%</td><td>11.27%</td><td>22.30%</td><td>24.40%</td><td>30.88%</td><td>23.51%</td><td>4.53%</td></tr><tr><td>600-699</td><td>1.60%</td><td>1.79%</td><td>10.64%</td><td>19.25%</td><td>23.76%</td><td>30.87%</td><td>26.92%</td><td>4.31%</td></tr><tr><td>700-799</td><td>1.20%</td><td>1.49%</td><td>9.77%</td><td>17.34%</td><td>21.14%</td><td>30.25%</td><td>28.74%</td><td>7.28%</td></tr><tr><td>800-899</td><td>1.22%</td><td>1.47%</td><td>8.66%</td><td>15.25%</td><td>21.71%</td><td>31.52%</td><td>29.58%</td><td>10.00%</td></tr><tr><td>900-999</td><td>1.10%</td><td>1.29%</td><td>7.13%</td><td>13.14%</td><td>19.75%</td><td>31.02%</td><td>30.05%</td><td>11.51%</td></tr><tr><td>1000-1299</td><td>0.98%</td><td>1.30%</td><td>6.45%</td><td>10.50%</td><td>15.28%</td><td>30.08%</td><td>30.45%</td><td>5.97%</td></tr><tr><td>1300-1499</td><td>0.69%</td><td>0.95%</td><td>4.20%</td><td>8.11%</td><td>14.46%</td><td>31.63%</td><td>33.09%</td><td>6.88%</td></tr><tr><td>1500-1799</td><td>0.61%</td><td>0.81%</td><td>3.85%</td><td>7.46%</td><td>11.16%</td><td>32.89%</td><td>35.22%</td><td>8.60%</td></tr><tr><td>1800-1999</td><td>0.61%</td><td>0.79%</td><td>3.71%</td><td>7.09%</td><td>10.48%</td><td>32.52%</td><td>35.23%</td><td>9.58%</td></tr><tr><td>2000+</td><td>4.29%</td><td>0.96%</td><td>2.64%</td><td>7.46%</td><td>8.39%</td><td>34.39%</td><td>15.27%</td><td>23.80%</td></tr><tr><td>合计</td><td>5.51%</td><td>6.28%</td><td>18.15%</td><td>23.38%</td><td>18.87%</td><td>19.11%</td><td>8.37%</td><td>1.32%</td></tr></tbody></table>',5)]))}const g=d(i,[["render",s],["__file","redis.html.vue"]]),p=JSON.parse('{"path":"/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/TroubleShootin/redis.html","title":"redis","lang":"zh-CN","frontmatter":{"draw":null,"tags":[],"title":"redis","date created":"2024-07-10T00:00:00.000Z","date modified":"2024-11-12T00:00:00.000Z","description":"大 key 治理 秒写回 在 Redis 中出现大 Key（即某个键所存储的数据过于庞大、数据量特别大）会引发一系列问题，例如内存占用过大、网络传输成本过高、阻塞 Redis 主线程导致延迟飙升、数据迁移和扩容困难等。为了更好地治理和优化大 Key，通常需要从数据模型设计、数据分片、访问模式优化、持久化策略与监控告警等多方面入手。以下是较为系统的思路和...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/TroubleShootin/redis.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:title","content":"redis"}],["meta",{"property":"og:description","content":"大 key 治理 秒写回 在 Redis 中出现大 Key（即某个键所存储的数据过于庞大、数据量特别大）会引发一系列问题，例如内存占用过大、网络传输成本过高、阻塞 Redis 主线程导致延迟飙升、数据迁移和扩容困难等。为了更好地治理和优化大 Key，通常需要从数据模型设计、数据分片、访问模式优化、持久化策略与监控告警等多方面入手。以下是较为系统的思路和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-11T14:48:27.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-11T14:48:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-11T14:48:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1732465042000,"updatedTime":1733928507000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":2}]},"readingTime":{"minutes":4.58,"words":1374},"filePathRelative":"2 第二大脑/1 节点/CS/编程语言/Java/TroubleShootin/redis.md","localizedDate":"2024年11月25日","autoDesc":true}');export{g as comp,p as data};
