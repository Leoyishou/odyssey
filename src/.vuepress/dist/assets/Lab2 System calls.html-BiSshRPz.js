import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,f as a,o as l}from"./app-DokaGNO4.js";const n={};function t(d,s){return l(),e("div",null,s[0]||(s[0]=[a(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="一、system-call-tracing-思路" tabindex="-1"><a class="header-anchor" href="#一、system-call-tracing-思路"><span>一、System call tracing 思路</span></a></h2><h3 id="_1-为什么要做系统调用追踪" tabindex="-1"><a class="header-anchor" href="#_1-为什么要做系统调用追踪"><span>1. 为什么要做系统调用追踪</span></a></h3><p>在后续调试各种功能（尤其是内核相关功能）时，如果能在内核态“看见”当前进程调用了哪些系统调用、返回值是什么，会非常方便排查 Bug。因此，Lab2 的第一个子实验要求你为 xv6 添加一个 <code>trace</code> 系统调用，用于打开/关闭对应进程的“系统调用追踪”开关，并在追踪打开时打印出所有被追踪的系统调用的<strong>名称</strong>、<strong>返回值</strong>以及<strong>发起调用的进程 PID</strong>。</p><h3 id="_2-实验大致做法" tabindex="-1"><a class="header-anchor" href="#_2-实验大致做法"><span>2. 实验大致做法</span></a></h3><ol><li><p><strong>添加系统调用 <code>trace</code></strong></p><ul><li>在 <code>kernel/syscall.h</code> 中定义 <code>SYS_trace</code> 的编号。</li><li>在 <code>kernel/syscall.c</code> 中把新的编号映射到你写好的内核处理函数 <code>sys_trace()</code>。</li><li>在 <code>kernel/sysproc.c</code> 里实现 <code>sys_trace()</code> 函数，核心逻辑就是给当前进程（<code>myproc()</code>）的 <code>syscall_trace</code> 赋值。</li><li>在用户态则需要在 <code>usys.pl</code>、<code>user.h</code> 等处为 <code>trace</code> 添加跳板函数和声明，如此才能从用户态方便地调用 <code>trace(mask)</code>。</li></ul></li><li><p><strong>在 <code>proc.h</code> 中为进程添加一个 <code>syscall_trace</code> 字段</strong><br> 这个字段用来存储“需要追踪哪些系统调用”的 bitmask，比如如果你传入的 mask 的某一位是 1，就代表需要追踪对应编号的系统调用。</p><ul><li>父进程在 fork 的时候会把这个 <code>syscall_trace</code> 传给子进程，这样父进程设置了 trace 之后，子进程也自动开启对应的追踪。</li></ul></li><li><p><strong>在 <code>syscall()</code> 这个“统一处理入口”里去打印日志</strong><br> xv6 中所有系统调用都会在内核态走到 <code>syscall(void)</code> 函数，所以要做“哪几个系统调用被追踪并打印”的工作，自然就放在这里最好。</p><ul><li>先根据寄存器 <code>a7</code> 拿到系统调用编号 <code>num</code>。</li><li>调用正确的内核处理函数，得到系统调用的返回值 (存入 <code>p-&gt;trapframe-&gt;a0</code>)。</li><li>如果进程的 <code>syscall_trace</code> 对应 bit 置位，就通过 <code>printf</code> 打印出 <code>pid</code>, <code>syscall name</code>, <code>return value</code> 等信息。</li></ul></li></ol><h2 id="trace-的实现效果" tabindex="-1"><a class="header-anchor" href="#trace-的实现效果"><span>trace 的实现效果</span></a></h2><p>在你完成 <strong>trace</strong> 系统调用并编译好 xv6 之后，你的 shell 里会多出一个用户态的可执行程序（通常叫 <strong><code>trace</code></strong>），用法大致是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>trace &lt;mask&gt; &lt;command&gt; [&lt;args&gt;...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong><code>&lt;mask&gt;</code></strong>：一个整数，里面的各个 bit 控制是否追踪对应编号（<code>SYS_xxx</code>）的系统调用。</li><li><strong><code>&lt;command&gt;</code></strong>：要执行的命令或程序。</li><li><strong><code>&lt;args&gt;...</code></strong>：该命令需要的参数。</li></ul><p><strong>当 trace 启动 <code>&lt;command&gt;</code> 时，只要 <code>&lt;mask&gt;</code> 对某个系统调用的编号进行“位掩码”匹配，这个系统调用就会被跟踪，并在命令执行期间每次系统调用返回前打印一行</strong>。输出格式类似：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;进程ID&gt;: syscall &lt;系统调用名&gt; -&gt; &lt;返回值&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>下面给你举一些在 xv6 shell 里可能看到的例子，方便了解 trace 实际如何工作。</p><hr><h3 id="_1-只追踪一个系统调用-比如-read" tabindex="-1"><a class="header-anchor" href="#_1-只追踪一个系统调用-比如-read"><span>1. 只追踪一个系统调用（比如 <code>read</code>）</span></a></h3><p>假设在 xv6 内核的 <code>kernel/syscall.h</code> 中，<code>SYS_read</code> 的编号是 5，那么它的位掩码就是 <code>1 &lt;&lt; 5 = 32</code>。于是：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> trace</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 32</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> hello</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> README</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这会只追踪 <code>SYS_read</code>。示例输出可能是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>3: syscall read -&gt; 1023</span></span>
<span class="line"><span>3: syscall read -&gt; 966</span></span>
<span class="line"><span>3: syscall read -&gt; 70</span></span>
<span class="line"><span>3: syscall read -&gt; 0</span></span>
<span class="line"><span>3: syscall close -&gt; 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这里显示进程 PID 为 3，<code>read</code> 每次返回了多少字节，最后还有一次 <code>close</code>（如果你也把 <code>close</code> 的掩码打开，就会显示它的踪迹）。</p></blockquote><p>由于这里只设置了掩码 <code>32</code>（即只跟踪 <code>read</code>），所以 <code>exec</code>、<code>open</code> 等其他系统调用并不会输出。</p><hr><h3 id="_2-跟踪所有系统调用" tabindex="-1"><a class="header-anchor" href="#_2-跟踪所有系统调用"><span>2. 跟踪所有系统调用</span></a></h3><p>如果你想看某个程序的<strong>所有系统调用</strong>，可以把 31 位都置为 1，比如 <code>2147483647 = 0x7fffffff</code>，这是一个常见的“所有位都打开”的掩码：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> trace</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2147483647</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> hello</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> README</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>输出示例（省略部分）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>4: syscall trace -&gt; 0</span></span>
<span class="line"><span>4: syscall exec -&gt; 3</span></span>
<span class="line"><span>4: syscall open -&gt; 3</span></span>
<span class="line"><span>4: syscall read -&gt; 1023</span></span>
<span class="line"><span>4: syscall read -&gt; 966</span></span>
<span class="line"><span>4: syscall read -&gt; 70</span></span>
<span class="line"><span>4: syscall read -&gt; 0</span></span>
<span class="line"><span>4: syscall close -&gt; 0</span></span>
<span class="line"><span>...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>可以看到这时会打印 <code>trace</code>, <code>exec</code>, <code>open</code>, <code>read</code>, <code>close</code> 等所有调用及它们的返回值。</p></blockquote><hr><h3 id="_3-不追踪任何系统调用" tabindex="-1"><a class="header-anchor" href="#_3-不追踪任何系统调用"><span>3. 不追踪任何系统调用</span></a></h3><p>如果 <code>&lt;mask&gt;</code> 是 0，那么不会打印任何跟踪信息：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> trace</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> hello</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> README</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此时 grep 照常执行，但不会输出任何 “syscall … -&gt; …” 行。</p><hr><h3 id="_4-追踪-fork-及其子进程的-fork" tabindex="-1"><a class="header-anchor" href="#_4-追踪-fork-及其子进程的-fork"><span>4. 追踪 fork 及其子进程的 fork</span></a></h3><p>假设 <code>SYS_fork</code> 的编号是 1，那么掩码就是 <code>1 &lt;&lt; 1 = 2</code>。 例如，有个测试程序叫 <code>forkforkfork</code>（会连续地 fork 好几次）：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> trace</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> usertests</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forkforkfork</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">usertests</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> starting</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">test</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forkforkfork:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">407:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">408</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">408:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">409</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">409:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">410</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">410:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">411</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">409:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">412</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">410:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">413</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">409:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">414</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">411:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> syscall</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> fork</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">415</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为你在父进程中打开了 trace，同时在 <code>fork()</code> 的实现里会把 <code>trace mask</code> 复制到子进程，所以后面所有子进程也继续带着同样的跟踪掩码——只要它们调用 <code>fork</code>，就会打出类似的行。</p><hr><h3 id="_5-追踪多个系统调用" tabindex="-1"><a class="header-anchor" href="#_5-追踪多个系统调用"><span>5. 追踪多个系统调用</span></a></h3><p>如果你想一次追踪多个系统调用，比如 <code>fork</code> (<code>SYS_fork</code>) 和 <code>read</code> (<code>SYS_read</code>)，可以把对应的位掩码“或”起来。举例：</p><ul><li><code>SYS_fork</code> 编号是 1 → <code>1 &lt;&lt; 1 = 2</code></li><li><code>SYS_read</code> 编号是 5 → <code>1 &lt;&lt; 5 = 32</code></li></ul><p>那么 “2 | 32 = 34” 就会同时追踪 <code>fork</code> 和 <code>read</code>。你可以在 shell 中：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> trace</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 34</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> somecommand</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><strong><code>trace &lt;mask&gt; &lt;command&gt;</code></strong> 会启动 <code>&lt;command&gt;</code> 并对 <code>&lt;mask&gt;</code> 指定的系统调用进行跟踪。</li><li><strong>输出格式</strong>：<code>PID: syscall xxx -&gt; return_value</code>。</li><li><strong>子进程继承</strong>：一旦某进程调用了 <code>trace(mask)</code>, 该进程后续的子进程也会带着相同的 <code>mask</code>。</li></ul><p>通过这些示例，你就能看到 <strong>trace</strong> 在 xv6 shell 里具体如何工作、以及它如何帮助你调试或观察系统调用的执行状况。祝你实验顺利!</p>`,48)]))}const c=i(n,[["render",t],["__file","Lab2 System calls.html.vue"]]),p=JSON.parse('{"path":"/1%20%E4%B8%80%E5%88%87%E7%9A%86%E9%A1%B9%E7%9B%AE/Q2%EF%BC%9A%E5%81%9ACS%E7%9A%84%E7%BB%8F%E5%85%B8lab/MIT%206.828/lab/Lab2%20System%20calls.html","title":"","lang":"zh-CN","frontmatter":{"description":"一、System call tracing 思路 1. 为什么要做系统调用追踪 在后续调试各种功能（尤其是内核相关功能）时，如果能在内核态“看见”当前进程调用了哪些系统调用、返回值是什么，会非常方便排查 Bug。因此，Lab2 的第一个子实验要求你为 xv6 添加一个 trace 系统调用，用于打开/关闭对应进程的“系统调用追踪”开关，并在追踪打开时打...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/1%20%E4%B8%80%E5%88%87%E7%9A%86%E9%A1%B9%E7%9B%AE/Q2%EF%BC%9A%E5%81%9ACS%E7%9A%84%E7%BB%8F%E5%85%B8lab/MIT%206.828/lab/Lab2%20System%20calls.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:description","content":"一、System call tracing 思路 1. 为什么要做系统调用追踪 在后续调试各种功能（尤其是内核相关功能）时，如果能在内核态“看见”当前进程调用了哪些系统调用、返回值是什么，会非常方便排查 Bug。因此，Lab2 的第一个子实验要求你为 xv6 添加一个 trace 系统调用，用于打开/关闭对应进程的“系统调用追踪”开关，并在追踪打开时打..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-27T06:52:25.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-27T06:52:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-27T06:52:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、System call tracing 思路","slug":"一、system-call-tracing-思路","link":"#一、system-call-tracing-思路","children":[{"level":3,"title":"1. 为什么要做系统调用追踪","slug":"_1-为什么要做系统调用追踪","link":"#_1-为什么要做系统调用追踪","children":[]},{"level":3,"title":"2. 实验大致做法","slug":"_2-实验大致做法","link":"#_2-实验大致做法","children":[]}]},{"level":2,"title":"trace 的实现效果","slug":"trace-的实现效果","link":"#trace-的实现效果","children":[{"level":3,"title":"1. 只追踪一个系统调用（比如 read）","slug":"_1-只追踪一个系统调用-比如-read","link":"#_1-只追踪一个系统调用-比如-read","children":[]},{"level":3,"title":"2. 跟踪所有系统调用","slug":"_2-跟踪所有系统调用","link":"#_2-跟踪所有系统调用","children":[]},{"level":3,"title":"3. 不追踪任何系统调用","slug":"_3-不追踪任何系统调用","link":"#_3-不追踪任何系统调用","children":[]},{"level":3,"title":"4. 追踪 fork 及其子进程的 fork","slug":"_4-追踪-fork-及其子进程的-fork","link":"#_4-追踪-fork-及其子进程的-fork","children":[]},{"level":3,"title":"5. 追踪多个系统调用","slug":"_5-追踪多个系统调用","link":"#_5-追踪多个系统调用","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1732465042000,"updatedTime":1735282345000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":2}]},"readingTime":{"minutes":4.65,"words":1394},"filePathRelative":"1 一切皆项目/Q2：做CS的经典lab/MIT 6.828/lab/Lab2 System calls.md","localizedDate":"2024年11月25日","autoDesc":true}');export{c as comp,p as data};
