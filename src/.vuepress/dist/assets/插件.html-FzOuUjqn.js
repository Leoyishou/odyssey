import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,f as a,o as r}from"./app-DokaGNO4.js";const s={};function p(c,e){return r(),t("div",null,e[0]||(e[0]=[a("<p>在 Java 的世界里没有直接对应 <code>-buildmode=plugin</code> 的概念，因为 Java 本身不通过编译器直接输出原生动态链接库（.so文件），而是通过字节码（.class）和打包好的 JAR 文件来实现动态加载。但是从功能和用途的角度类比，可以将这个步骤类比成：</p><p><strong>&quot;将你的映射与规约函数打包成独立的、可在运行时动态加载的模块&quot;</strong>。</p><p>在 Java 中可能会这样做：</p><ol><li><p><strong>编译生成 class 文件后打包成 JAR：</strong><br> 你可能会有一个包含特定接口实现的类文件，比如 <code>MyMapReduce.jar</code>。这个 JAR 文件里包含实现了特定接口（比如 <code>Map</code>、<code>Reduce</code> 方法）的类。</p></li><li><p><strong>通过类加载器（URLClassLoader 或类似机制）在运行时加载：</strong><br> 当你的主程序运行时，你可以通过 Java 的反射或自定义的类加载器在运行时从外部的 JAR 文件中加载特定的类，然后调用这个类的特定方法。这一点在理念上类似 Go 中通过 <code>-buildmode=plugin</code> 生成 <code>.so</code> 文件，并在主程序中使用 <code>plugin.Open()</code> 来动态加载并调用插件中的函数。</p></li></ol><p>总结一下：</p><ul><li><strong>Go 的插件（.so）</strong>：本质是已编译成机器码的共享库，运行时通过 <code>plugin</code> 包加载。</li><li><strong>Java 的类/JAR</strong>：本质是字节码文件（.class）打包在 JAR 中，运行时通过 <code>ClassLoader</code> 动态加载类。</li></ul><p>所以，<strong>在概念层面上，这一步相当于在 Java 中编译并打包出一个包含特定接口实现的 JAR 文件，然后在主程序里使用类加载器动态加载这个 JAR 文件，从而获取所需的类和方法。</strong></p>",7)]))}const l=o(s,[["render",p],["__file","插件.html.vue"]]),d=JSON.parse('{"path":"/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E6%8F%92%E4%BB%B6.html","title":"","lang":"zh-CN","frontmatter":{"description":"在 Java 的世界里没有直接对应 -buildmode=plugin 的概念，因为 Java 本身不通过编译器直接输出原生动态链接库（.so文件），而是通过字节码（.class）和打包好的 JAR 文件来实现动态加载。但是从功能和用途的角度类比，可以将这个步骤类比成： \\"将你的映射与规约函数打包成独立的、可在运行时动态加载的模块\\"。 在 Java 中...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/2%20%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/1%20%E8%8A%82%E7%82%B9/CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E6%8F%92%E4%BB%B6.html"}],["meta",{"property":"og:site_name","content":"转了码的刘公子"}],["meta",{"property":"og:description","content":"在 Java 的世界里没有直接对应 -buildmode=plugin 的概念，因为 Java 本身不通过编译器直接输出原生动态链接库（.so文件），而是通过字节码（.class）和打包好的 JAR 文件来实现动态加载。但是从功能和用途的角度类比，可以将这个步骤类比成： \\"将你的映射与规约函数打包成独立的、可在运行时动态加载的模块\\"。 在 Java 中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-11T14:48:27.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-11T14:48:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-11T14:48:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"转了码的刘公子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1733928507000,"updatedTime":1733928507000,"contributors":[{"name":"Luis","email":"liuysh20@gmail.com","commits":1}]},"readingTime":{"minutes":1.44,"words":433},"filePathRelative":"2 第二大脑/1 节点/CS/编程语言/Go/插件.md","localizedDate":"2024年12月11日","autoDesc":true}');export{l as comp,d as data};
