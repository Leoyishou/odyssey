---
draw:
tags: []
title: Lab0 Networking Warmup
date created: 2024-12-30
date modified: 2025-01-15
---

这个代码是 Stanford CS144 (Computer Networking) 课程中第一个 lab 的一部分，实现了一个基本的字节流（ByteStream）抽象。这个实现的目的和意义包括：

1. 构建 TCP 的基础
   - ByteStream 是实现 TCP 协议的基础组件之一
   - 它模拟了 TCP 中可靠数据传输的基本机制
   - 提供了流量控制的基本实现（通过 capacity 限制）

2. 实现重要的抽象概念
   - 实现了一个有限容量的缓冲区
   - 处理了数据的写入（write）和读取（read）操作
   - 管理了流的开始和结束状态

3. 核心功能包括：
   - write：向流中写入数据
   - read：从流中读取数据
   - peek_output：预览数据但不移除
   - pop_output：移除数据但不返回
   - 流量控制：通过 capacity 限制缓冲区大小
   - 状态跟踪：记录已读/已写字节数，检查流是否结束

4. 教学目的
   - 帮助理解计算机网络中的流控制概念
   - 练习基本的数据结构操作
   - 为后续实现更复杂的 TCP 功能打基础

这个实验是整个 TCP 实现项目的第一步，通过实现这个基础的字节流，学生可以更好地理解 TCP 协议中的数据流动机制，为后续实现更复杂的 TCP 功能（如可靠传输、流量控制等）打下基础。

## 通过 capacity 限制 是怎么体现出来的

这种容量限制机制模拟了 TCP 中的流量控制：

发送方不能无限制地发送数据  
接收方有一个固定大小的接收窗口  
当接收窗口满时，发送方必须等待接收方处理数据后才能继续发送

### write

让我用 ASCII 图解释这段代码的逻辑：

```Java
【ByteStream 的缓冲区示意图】

capacity = 10 (总容量)
buffer.size() = 4 (已使用空间)
canWrite = capacity - buffer.size() = 6 (剩余可写空间)

+---+---+---+---+---+---+---+---+---+---+
| A | B | C | D |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+
|<--- 已使用 --->|<----- 剩余空间 ----->|
|<--------------- capacity ------------->|


假设要写入的数据：data = "HELLO" (长度为5)
canWrite = 6 (剩余空间)
canRead = min(6, 5) = 5 (实际可写入长度)

写入后的状态：
+---+---+---+---+---+---+---+---+---+---+
| A | B | C | D | H | E | L | L | O |   |
+---+---+---+---+---+---+---+---+---+---+
```

再举一个例子，如果要写入的数据比剩余空间大：

```Java
当前状态：
+---+---+---+---+---+---+---+---+---+---+
| A | B | C | D |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+

要写入：data = "HELLOWORLD" (长度为10)
canWrite = 6 (剩余空间)
canRead = min(6, 10) = 6 (只能写入6个字符)

写入后：
+---+---+---+---+---+---+---+---+---+---+
| A | B | C | D | H | E | L | L | O | W |
+---+---+---+---+---+---+---+---+---+---+
                    |<---- 实际写入 ---->|
```

计算逻辑：

1. `canWrite = capacity - buffer.size()`
   - 计算还有多少空闲空间可以写入
   - 就是总容量减去已使用空间

2. `canRead = min(canWrite, data.size())`
   - 比较剩余空间和要写入的数据长度
   - 取两者中的较小值作为实际可写入长度
   - 这样可以避免缓冲区溢出

这就像往一个固定大小的水杯里倒水：

- capacity 是水杯的容量
- buffer.size() 是已经装的水量
- canWrite 是还能装多少水
- data.size() 是想要倒入的水量
- canRead 是实际能倒入的水量

## 参考

https://doraemonzzz.com/2022/01/30/2022-1-30-CS144-Lab0%E7%BF%BB%E8%AF%91/#4-%E5%86%85%E5%AD%98%E4%B8%AD%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%AD%97%E8%8A%82%E6%B5%81

1. 在你的提交中，请只对`webget.cc`和`libsponge`顶层的源代码（`byte_stream.hh`和`byte_stream.cc`）进行修改。请不要修改`libsponge/util`中的任何测试或帮助程序。
2. 在提交任何作业之前，请按顺序运行这些：
    - (a) `make format`(使编码风格正常化)
    - (b) `make`(确保代码可以编译)
    - (c) `make check_lab0`(确保自动测试通过)
3. 完成编辑`writeups/lab0.md`，写上这项作业花了你多少时间，以及任何其他评论。
4. 准备提交时，请按照[https://cs144.github.io/submit](https://cs144.github.io/submit)。在提交之前，请确保你已经提交了你想要的一切。
5. 如有任何问题，请在周二晚上的实验课上尽快告知课程负责人，或在Piazza上发表问题。祝您好运，欢迎来到CS144!
