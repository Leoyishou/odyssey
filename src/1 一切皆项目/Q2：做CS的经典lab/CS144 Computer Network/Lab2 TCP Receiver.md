---
draw:
tags: []
title: Lab2 TCP Receiver
date created: 2024-12-30
date modified: 2025-01-02
---

## 代码 diff

从提供的代码差异中，我可以看到这是 CS144 (计算机网络) Lab2 的实现，主要完成了 TCP 接收端的部分功能。具体实现了以下几个关键组件：

1. ByteStream 的改进：
	- 优化了代码格式和结构
	- 实现了基础的流控制功能
	- 包括读写操作、缓冲区管理等功能

2. StreamReassembler (流重组器) 的实现：
	- 负责处理可能乱序到达的 TCP 数据段
	- 使用 buffer 和 bitmap 来追踪和重组数据
	- 实现了 `check_contiguous()` 方法来处理连续数据的推送
	- 添加了 `ack_index()` 方法来跟踪确认序号

3. TCPReceiver (TCP 接收器) 的实现：
	- 处理 TCP 报文段的接收逻辑
	- 管理 SYN 和 FIN 标志的处理
	- 实现了序列号的转换和管理
	- 维护接收窗口大小
	- 处理确认号（ackno）的生成

4. WrappingIntegers (包装整数) 的改进：
	- 实现了序列号的封装和解封装
	- 处理 32 位序列号的回绕问题
	- 提供了序列号的算术运算支持

这个 lab 的核心在于实现 TCP 接收端的基本功能，特别是：  
	- 数据的接收和重组  
	- 序列号的管理  
	- 流量控制  
	- 处理 TCP 连接的建立和终止标志（SYN/FIN）

这些实现为后续构建完整的 TCP 协议栈打下了基础。

## 绝对序号

下面给出一个形象化（直观）的解释，帮助大家理解为什么要在计算绝对序号时，对比 `± (1ul << 32)` 后选择与最近一次 `checkpoint` 最接近的那个。

---

### 1. "32 bits 的 seqno 会循环"这个特性

#### 场景比喻：12 小时制的时钟

- **传统的 TCP sequence number 是 32 bits，会发生"回绕（wrap around）"。**  
    就像一个只有 12 小时刻度的时钟，会在指针转满一圈后，从 `11:59` 跳回到 `0:00`，继续循环使用。
- 所以你看到的"时钟显示"**不是唯一**的，它每 12 小时就会从头开始，无法直接区分今天的 10:00 和昨天的 10:00。

#### 问题：如何确定"真正的时间"？

- 如果只知道当前时间是 "10:00"，并不知道现在是上午还是晚上，单看时针本身并不能确定具体是哪一天或哪一次循环。
- **但我们有一个"基准点（checkpoint）"**：比如我们知道"最近一次我们确认的时间是 9:58 AM"，那么我们就可以猜测：现在这 10:00 很可能就是在"9:58 AM 之后的 2 分钟"，而**不会**是隔了 12 个小时以后的 10:00 PM。

---

### 2. "绝对序号"就是不回绕的时间线

- **对比"12 小时制时钟"**：你可能用一个 24 小时制或干脆用一个"Unix 时间戳"来记录不同时刻，它不会循环回绕，也不会重复。
- 在 TCP 协议里，**我们自己维护一个"64 bits 不回绕"的 absolute sequence number**，对应真实的"从数据流开始到现在"的字节位置计数。
- 当对方发来一个 32 bits 的 seqno（就是"12 小时制的时间"），要把它折算到我们自己的 64 bits 时间轴（就是"Unix 时间戳"）。

---

### 3. 为什么要选"与 checkpoint 最接近的那个"？

#### 原理 / 直觉

- "seqno" 可能是 "时钟"上的一个读数，例如 "10:00"。
    
- 我们当前维护的 "checkpoint" 表示我们上一次计算出的 **absolute seqno**（相当于"上次确认好的 Unix 时间戳"）。
    
- 当我们再看到一个新的 "10:00" 时，为了转换到"Unix 时间戳"上，就要判断：
    
    - 它是"9:58 AM" 后 2 分钟吗？
    - 还是其实已经过了 12 个小时，变成了"10:00 PM"？
    - 甚至可能过了 24 小时、36 小时...（只是极少见/几乎不可能发生那么大延迟）
- **正常情况下**，两个分段（segment）相邻到达的序列号不会相差一个 **2^31**（＝INT32_MAX）以上的量，除非真的隔了很多小时、甚至几天才到达，这在常规网络里非常罕见。
    

#### 数学实现

- 对于给定的 `seqno_32`（32 bits seqno），我们先用已知的 `checkpoint`（64 bits absolute seqno）来猜测：
    - 先把 `seqno_32` 转成一个基础的 `abs_seqno_candidate`，比如直接 `(seqno_32 - ISN) + 0`；
    - 再分别尝试加/减 `1 << 32`，形成多个可能的候选值：
        1. candidate0=base\text{candidate}_0 = \text{base}
        2. candidate1=base+232\text{candidate}_1 = \text{base} + 2^{32}
        3. candidate−1=base−232\text{candidate}_{-1} = \text{base} - 2^{32}
- 选出其中与 `checkpoint` **差的绝对值最小**的那一个，就代表"最有可能的绝对时间（绝对序号）"。

**直观理解**：

- 就像"现在是 10:00"，可能对应今天上午 10:00、今晚 10:00、明天 10:00...
- 但根据你"刚才是 9:58"的记录，肯定选"上午 10:00"（只差 2 分钟）最合理，而不是"隔 12 小时"或更久以后。

---

### 4. 结论

在实现时：

1. **存储一个"checkpoint"（上一次确认好的 64 bits absolute seqno）**。
2. 每次接收新的 32 bits `seqno` 时，算出几个可能的 64 bits 候选值。
3. **选择距离 `checkpoint` 最接近的候选值**。
4. 这样就可以将一个会回绕的 32 bits 序号，映射到一个不回绕的 64 bits **absolute seqno** 上。

**形象总结**：

- 32 bits 的序号就像一个"12 小时制时钟"不停地转圈；
- `checkpoint` 则是上一次你确认了"确切的时间"。
- 当你再看到一个钟面读数时，就把它对应到最接近你上次确认时间的那一点上，这样就能**唯一确定**它在时间轴上的位置。

这就是我们为何要在计算出的绝对序号（absolute seqno）上下 **±1×232\pm 1 \times 2^{32}** 做比较，选择离 `checkpoint` 最近值的根本原因。
