---
date created: 2024-10-23
date modified: 2025-07-21
uid: 86ab67ca-3078-4548-a0cb-01a0125da483
aliases: [SFT 与 GRPO 的差异与联系]
linter-yaml-title-alias: SFT 与 GRPO 的差异与联系
---

![CleanShot 2025-06-15 at 01.27.00@2x.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fmedia%2Fmedia_Hbom7G6ctX%2F2025%2F06%2F15%2F01-27-10-2c55bcdab4cb8bee159948b25a535fc3-CleanShot%202025-06-15%20at%2001.27.00-2x-9cf54f.png)

以下是关于微调方法的三种方式的中文表格总结：

| 方式 | 描述 | 示例 | 费用结构 |
|------|------|------|----------|
| 商业模型提供商微调 | 模型供应商提供商业模型的在线微调能力 | OpenAI 的 GPT-3.5 | 按 token 付费 |
| 云厂商平台 | 云厂商提供的模型部署、微调平台 | 阿里云的 PAI 平台（DeepSeek 模型）| 只需使用云厂商的 GPU 算力 |
| 自托管开源方案 | 适合拥有足够强大 GPU 的公司，希望完全本地私有化 | 各种开源方案配合自部署微调平台 | 需要自备硬件并搭建基础设施 |

___

是的，**Supervised Fine-Tuning (SFT)** 和 **Group Relative Policy Optimization (GRPO)** 是两个并列但不同的模型训练方法，它们分别属于不同类型的技术路线，用于改善大语言模型（LLM）的表现。下面用通俗易懂的语言展开解释一下：

# SFT 与 GRPO 的差异与联系

| 区别项  | SFT（监督式微调）| GRPO（群组相对策略优化）|
| ---- | ---------------------------------- | ------------------------------------------------ |
| 核心思想 | 直接模仿预先提供的标准答案                      | 根据生成答案的好坏反馈优化                                    |
| 所需数据 | 必须要有高质量标注数据（正确答案）| 不需要完整标准答案，只需要好坏评价                                |
| 适用场景 | 需要稳定、可控的答案场景                       | 希望生成更灵活、更有创造性的答案                                 |
| 模型表现 | 更倾向模仿原始数据，更稳定                      | 更倾向探索新答案，可能更具创新性                                 |
| 训练难度 | 相对简单易操作                            | 相对复杂，需要建立有效的反馈系统                                 |
|      | - **SFT** 像"背课文"，给了标准答案，模型照着学；<br> | **GRPO** 像"实战训练"，不给标准答案，只告诉模型表现好坏，让模型自己探索出更好的方式。|

---

# 一、Supervised Fine-Tuning (SFT) - 监督式微调

**简单来说**：

- 就像学生做作业，由老师给出正确答案，然后学生反复练习直到掌握一样。
- 在SFT中，模型就像是"学生"，我们事先准备好大量高质量的问题和答案数据，让模型去学习这些数据，记住正确的回答方式。
- 这种方式的关键是**预先准备好的数据质量**，数据越准确、越丰富，模型的表现就越好。

**举个例子**：

> 假设你要训练一个聊天机器人回答数学问题。
> 你准备了10万道数学题，每道题都附有详细的标准答案（步骤 + 答案）。
> 模型通过学习这些题目的答案，慢慢掌握了数学题的解答方法，以后遇到类似的题目就可以正确地回答了。

**特点总结**：

- 依赖提前准备的高质量标注数据。
- 模型会忠实地学习和模仿数据中给出的答案风格和逻辑。
- 训练起来相对容易，但受限于数据的质量和数量。

---

# 二、Group Relative Policy Optimization (GRPO) - 群组相对策略优化

**简单来说**：

- GRPO是一种强化学习（RL）的方法，和上面监督学习完全不同。
- 在强化学习中，模型并不是从标准答案直接学习，而是通过不断的"尝试与反馈"来优化。
- 模型生成一些答案后，我们给每个答案打分（好/不好），模型就根据这些反馈慢慢优化，逐渐提升表现。
- **GRPO**的特色在于，它不是逐个单独评价答案，而是**一批（群组）一批地评价答案**，再用这些群组的相对得分差异来帮助模型理解怎样的回答更好。

**举个例子**：

> 同样训练一个解答数学题的机器人，这次你不给标准答案，而是让模型自己生成10个答案，然后人类（或自动化评分系统）对这10个答案整体评分，比如：
>
> - 第1个答案：得分 70分
> - 第2个答案：得分 90分
> - 第3个答案：得分 50分
> - ……
>
> 然后模型再仔细观察：『为什么第2个答案得分最高？』
>『第3个答案错在哪里？』
>『第1个答案少了什么步骤？』
>
> 经过反复尝试，模型逐渐明白"高分答案"长什么样，从而表现越来越好。

**特点总结**：

- 通过不断试错和反馈提高模型表现，更有"探索"的感觉。
- 不再需要提前准备详细的标准答案，但需要高质量的评分体系。
- GRPO的优势在于让模型能生成更灵活、更有创造性的答案，而不仅仅局限于模仿预先准备的数据。

---

# 总结

- **SFT** 像"背课文"，给了标准答案，模型照着学；
- **GRPO** 像"实战训练"，不给标准答案，只告诉模型表现好坏，让模型自己探索出更好的方式。

在实际使用中，这两种方法经常被组合使用：

- 先用SFT打基础，让模型具备基本的能力。
- 再用GRPO进一步优化，让模型更灵活，更符合实际需要。

这样组合起来，可以达到更好的效果。

两者在基本思路上有相似之处，都是在预训练模型的基础上进行微调，使模型更适合特定任务。但细节上有明显差异：

| 路线              |                                                                                                                                                                                                         |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [监督微调 SFT](监督微调%20SFT.md)   | - **OpenAI 的微调模块**：<br>    通常采用监督学习的方式，你上传标注好的 JSONL 数据，然后选择一个基座模型，系统会利用这些标注数据对模型进行微调，调整模型的参数使其更适应你提供的训练数据。<br>                                                                                         |
| [[GRPO]] | - **[[GRPO]]-DeepseekR1 的方法**：<br>    这里使用的是强化学习策略优化（Group Relative Policy Optimization，GRPO）的方法。训练过程中不仅依赖监督信号，还引入了奖励函数（例如格式奖励、准确率奖励和编辑距离奖励）来评估生成结果，然后通过策略优化来调整模型。这种方法在生成任务中可以更灵活地控制输出格式和内容。<br> |

总结来说，虽然两者都是基于预训练模型的微调，但 OpenAI 的方法更偏向于传统的监督微调，而 GRPOTrainer 则结合了强化学习的策略优化，使得微调过程中可以直接用生成质量的反馈来调整模型。

___

https://github.com/huggingface/open-r1?tab=readme-ov-file

这个项目的目标是公开复现 DeepSeek-R1 模型，也就是说，它提供了一整套代码和工具，让大家可以按照公开的流程来微调和评估这个模型。简单来说：

- **复现 DeepSeek-R1**：项目重现了 DeepSeek-R1 的整个训练和微调过程，包括用监督学习（SFT）和基于强化学习的 GRPO 方法来改进模型表现。
- **数据处理与生成**：它包含了数据预处理、数据生成（用来扩充训练数据）以及评估脚本，方便大家验证模型在数学推理、代码生成等任务上的表现。
- **开放与可扩展**：整个项目是开源的，目的是让更多人可以在这个基础上进行改进和二次开发，推动相关研究和应用。

换句话说，这个项目不是在从零开始训练一个模型，而是复现并改进已有的 DeepSeek-R1，通过公开的代码让大家都能用相同的方法来微调和评估模型。

___

# 参考资料

https://colab.research.google.com/drive/1T5-zKWM_5OD21QHwXHiV9ixTRR7k3iB9?usp=sharing

[hiyouga/LLaMA-Factory/LLaMA-Factory: 一键调用LLaMA-Factory ，轻松微调。集成多种辅助功能。 - CG (codewithgpu.com)](https://www.codewithgpu.com/i/hiyouga/LLaMA-Factory/LLaMA-Factory)

我来为您解释一下如何微调(fine-tune) Llama 模型，我会尽量用通俗的语言解释这个过程。

作为 Java 程序员转入 AI 领域，您需要了解以下几个关键概念和步骤:

1. 基本概念:
- 微调是指在预训练模型的基础上,用特定数据集进行进一步训练,使模型更适合特定任务
- LoRA(Low-Rank Adaptation)是一种高效的微调方法,只需要更新很小一部分参数(1-10%)
- 在这个例子中使用了 Unsloth 框架,它可以让训练速度提升 2 倍

1. 主要步骤:

a) 环境准备:

```python
# 安装必要的库
!pip install unsloth
```

b) 加载模型:

```python
from unsloth import FastLanguageModel

# 加载预训练模型
model, tokenizer = FastLanguageModel.from_pretrained(
    model_name = "unsloth/Llama-3.2-3B-Instruct",  # 选择模型
    max_seq_length = 2048,  # 最大序列长度
    load_in_4bit = True     # 使用4位量化以减少内存使用
)
```

c) 准备训练数据:

- 需要准备对话格式的数据,包含用户输入(user)和助手回答(assistant)
- 数据需要转换成模型可以理解的格式

d) 配置训练参数:

```python
# 设置 LoRA 参数
model = FastLanguageModel.get_peft_model(
    model,
    r = 16,                # LoRA 秩,建议值 8,16,32,64,128
    target_modules = ["q_proj", "k_proj", "v_proj", "o_proj",
                     "gate_proj", "up_proj", "down_proj"],
    lora_alpha = 16,
    lora_dropout = 0
)
```

e) 开始训练:

```python
from trl import SFTTrainer

trainer = SFTTrainer(
    model = model,
    tokenizer = tokenizer,
    train_dataset = dataset,
    dataset_text_field = "text"
)

trainer.train()
```

f) 保存模型:

```python
# 本地保存
model.save_pretrained("lora_model")
tokenizer.save_pretrained("lora_model")
```

1. 实用建议:
- 建议使用 Google Colab 等云平台进行训练,因为需要 GPU 资源
- 开始时可以用小数据集测试流程
- 确保训练数据质量,这对模型效果影响很大
- 可以先用较小的模型(如 1B 或 3B 参数量的版本)来测试
- 注意保存训练检查点,以防训练中断

1. 资源消耗参考:
- 使用 Tesla T4 GPU 训练时,峰值内存使用约 6.5GB
- 完整训练时间因数据集大小而异,示例中约 7.5 分钟

如果您想开始尝试:

1. 先在 Google Colab 上运行示例代码
2. 准备一个小的测试数据集
3. 逐步调整参数观察效果
4. 成功后再尝试使用自己的数据集进行训练

需要注意的是,虽然示例使用 Python,但您不需要精通 Python,只需要能看懂基本语法并修改关键参数即可。随着您的深入学习,可以逐步掌握更多 AI 相关知识。
