---
comment_id: 9debc268
date created: 2025-03-14
date modified: 2025-03-15
draw: null
title: viva前端CICD
---
根据你提供的前端部署配置，前端中实际使用的仓库变量和密码（`secrets`）如下：

---
  - `DOCKERHUB_USERNAME` louisleonard
  - `DOCKERHUB_TOKEN` dckr_pat_U2MIMviLW8x3YR5kAQS5k8RBrkA
  - `SERVER_HOST` 43.134.93.160
  - `SERVER_USERNAME` root
  - `SERVER_PASSWORD` Lys876538875..

## 📌 **前端需要的仓库机密（Secrets）**

|变量名（Secrets）|用途说明|
|---|---|
|`DOCKERHUB_USERNAME`|Docker Hub 用户名（用于镜像构建和推送）|
|`DOCKERHUB_TOKEN`|Docker Hub 密钥（用于镜像推送）|
|`SERVER_B_HOST`|部署服务器地址（IP 或域名）|
|`SERVER_B_USERNAME`|部署服务器登录用户名|
|`SERVER_B_PASSWORD`|部署服务器登录密码|

---

## 📌 **前端需要的仓库变量（Vars）**

**前端当前配置里** 没有明确使用 `vars`，一般情况下前端环境变量较少。但根据实际项目情况可能会涉及以下常见的变量（视实际需求而定）：

|变量名（Vars）（可选）|可能的用途（举例）|
|---|---|
|`VITE_API_BASE_URL`|API请求地址（后端服务器地址或接口路径）|
|`NODE_ENV`|环境变量（`production` 或 `development`）|
|`LOG_LEVEL`|日志级别（如：`INFO`或`ERROR`）|

> ⚠️ 以上变量不在你当前给定的部署脚本中体现，仅供参考。

---

## 📍 为什么要先构建 Docker 镜像上传到 Docker Hub？

这个流程背后的实际操作是：

- 你在 GitHub Actions 环境里完成了代码构建，把应用打包成**Docker镜像**（你可以理解成"软件的标准化快递包裹"）。
- 但这个时候构建出来的镜像**只存在于 GitHub Actions 运行的临时服务器**（也就是云端的临时环境）中。
- 接下来要在你的目标服务器运行这个应用时，目标服务器（也就是你的正式环境服务器）必须能**从某个地方拿到这个"软件包"**。

你有两个选择：

### 🟡 方法一（你当前使用的方法）：上传到 Docker Hub 再从 Docker Hub 下载

- 构建完成后，镜像被推送到 Docker Hub 公开或私有仓库。
- 服务器运行`docker-compose pull`或`docker-compose up`时，就自动**从 Docker Hub 下载镜像**。

> 比喻理解：
> 你工厂生产了一箱饮料，**不直接送去门店**，而是先存入了一个公共仓库（Docker Hub）。门店需要的时候，直接从仓库取货即可。

### 🔵 方法二（替代方案）：直接通过镜像文件上传到服务器（很少这么做）

- 先把 Docker 镜像导出成`.tar`文件，直接上传到服务器。
- 服务器再导入镜像，然后运行。

> 比喻理解：
> 就是工厂生产的饮料，你直接打包成一个大纸箱，用卡车运输到门店，再开箱摆上货架。

但是这个方式**通常更复杂、不灵活、维护成本较高**，且不易自动化，镜像文件往往很大，上传慢，而且需要额外处理镜像导入导出的过程。

---

## 📌 推荐用 Docker Hub 仓库的原因

### ① 简单高效

- Docker Hub 是专门为存储和分发 Docker 镜像设计的，非常方便服务器拉取镜像。

### ② 支持版本管理

- Docker Hub 上可以管理多个版本（tag），方便回滚。

### ③ 节省部署时间

- 使用 Docker Hub 仓库时，服务器只下载有更新的镜像层，而不是每次都要上传和解压整个镜像文件，节省大量时间。

### ④ 多服务器场景

- 如果你有多个服务器（比如开发服务器、测试服务器、生产服务器），用 Docker Hub 统一管理镜像，所有服务器只需简单拉取镜像即可完成更新，省去重复的文件传输和手动操作。

---

## 📝 总结

你当前的流程（上传 Docker Hub 镜像 + SCP 传送部分配置文件）是非常典型的、符合业界最佳实践的 CI/CD 流程。

- **镜像上传 Docker Hub** → 方便快速部署和版本管理。
- **配置文件用 SCP 上传到服务器** → 适用于频繁变动的配置、证书或特殊文件。

综合来看，你目前的做法是**更优雅、更高效、更易维护**的方案。

---

下面用形象生动的比喻，通俗易懂地解释一下你这个部署流程中每一步干了啥：

---

## 🚩 触发条件 (on push)

你写了个小纸条贴在办公室门口，上面写着：

- **"老板只要往main分支上推代码（相当于往'正式版'文件夹里放了新东西），我们就开工！"**

---

## 📦 Jobs（工作任务）

整个工作分两步：

### 🧪 1. 测试（test）

- 目前只是做个样子：
    - 一个工作人员（`ubuntu-latest`）走过来，喊一句：

        > "放心吧，前端测试一切正常！"

- 然后就告诉部署人员可以动手了。

---

### 🚀 2. 部署（deploy）

当收到测试通过的信号（test成功），我们就正式开工！

部署这一步更复杂，就像派了个经验丰富的快递员（`ubuntu-latest`）来专门处理上线部署任务。

他的任务包括以下步骤：

---

### 📂 步骤细节 (steps)

**（1）📥 拉取最新代码 (`Checkout code`)**

- 快递员先去仓库（GitHub）取最新版本的代码，这样能确保我们发货的是最新的东西。

---

**（2）📚 缓存 Docker 层 (`Cache Docker layers`)**

- 每次构建 Docker 镜像相当于做一道菜，缓存 Docker 层相当于提前把菜洗干净、切好，后续做菜（构建镜像）就更快了。

---

**（3）🛠️ 设置 Docker Buildx (`Set up Docker Buildx`)**

- 相当于提前安装好更专业的做菜工具（高级版厨具），能支持高级操作，让做菜更快更高效。

---

**（4）🔐 登录 Docker Hub (`Login to Docker Hub`)**

- 就像登录自家的网盘账号，准备上传新的镜像。

---

**（5）🧑‍🍳 启用 BuildKit (`Enable BuildKit`)**

- 就像打开了做菜的"加速模式"，更加高效和智能。

---

**（6）🍳 构建并推送前端镜像 (`Build and push frontend Docker image`)**

- 开始正式做菜：把代码和配置文件组合在一起，打包成一个便于运输的"盒饭"（Docker镜像）。
- 然后把这个"盒饭"上传到Docker Hub仓库，供后续使用。

---

**（7）♻️ 更新缓存 (`Move cache`)**

- 把刚才备好的食材（缓存）保存起来，下次做饭时还能更快。

---

**（8）📝 创建 Docker Compose 文件 (`Create docker-compose.yml`)**

- 创建了一张清单（Docker Compose文件），上面写着这次送去服务器的盒饭里有啥、放哪里、用什么配置，比如前端服务用的镜像、端口、SSL证书的位置。

---

**（9）📤 上传文件到服务器 (`Copy frontend files to server`)**

- 快递员带着打包好的docker-compose清单、SSL证书、Nginx配置文件去到生产服务器的指定位置，摆放好这些东西，等待后续部署。

---

**（10）📡 SSH 部署到服务器 (`Deploy Frontend to Server`)**

快递员现在直接远程连到服务器，开始部署：

- **设置权限**：
    
    - 就像理货员先整理好货架（文件夹），确保所有东西摆放整齐，有权限访问。
- **处理SSL证书目录**：
    
    - 确保证书的文件夹权限没问题，就像给存放贵重证件的保险柜上好锁。
- **停掉旧容器**：
    
    - 就像餐厅把原来售卖的旧盒饭（旧版服务）先下架。
- **拉取最新镜像**：
    
    - 从仓库里取最新出炉的盒饭（刚刚构建的Docker镜像）。
- **启动新容器**：
    
    - 把最新的盒饭摆上货架（服务器启动新容器），让客户（用户）能马上买到（访问到）最新的服务。
- **检查容器状态**：
    
    - 快递员再检查一遍货架，确保盒饭（容器）摆好了、卖正常了，如果发现异常，就看日志记录，排查一下。

---

✅ **完成**：

快递员开心地报告：

> "前端部署任务圆满完成啦！🎉🎉"

---

整体流程就像一次标准的餐厅出餐流程：

- **测试阶段**：厨房主管喊一嗓子"今天菜单可做！"
- **部署阶段**：厨师炒菜（构建镜像）→打包（推送镜像）→配送到门店（复制文件）→上架卖出（启动容器）→检查反馈（日志查看）。

这样解释是不是更清晰了呢？
