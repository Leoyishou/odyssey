---
comment_id: 77b1404f
date created: 2024-10-13
date modified: 2025-05-02
draw: null
title: pandas
---
pandas 在使用时语法感觉很乱，有什么学习的技巧吗？- 奕高的回答 - 知乎  
https://www.zhihu.com/question/289788451/answer/2167204031

## 索引器对象

- **语法**：只有 `[]` 才能触发订阅操作（`__getitem__` / `__setitem__`），圆括号不具备这一语义。
    
- **pandas**：`df.loc`、`df.iloc` 本质是索引器对象，规定“**用方括号表达我想取什么**”。
    
- **代码可读性**：在整个科学计算生态中，`[]` 已经约定俗成地代表“索引/切片”，保持一致能减少认知负担。

## DataFrame

![CleanShot 2025-05-02 at 15.43.05@2x.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fmedia%2Fmedia_FQKT0tTUKY%2F2025%2F05%2F02%2F15-43-48-f64a4b992f3086bcf56ae60f67f456aa-CleanShot%202025-05-02%20at%2015.43.05-2x-8b7998.png)

DataFramed 的本质是`Map<String, List>`，而 ndArray 的本质是 `List<List>`

DataFrame 是 pandas 库中最常用的数据结构之一。你可以把它想象成一个表格或者电子表格,就像 Excel 里的工作表。这个 " 表格 " 有行和列:

1. 每一列代表一种类型的数据 (比如姓名、年龄、成绩等)。
2. 每一行代表一条完整的记录。

NumPy的核心数据结构是ndarray（N-dimensional array，N维数组）。这与pandas的DataFrame有些不同，更像是Java中的数组，但可以有多个维度。

   - 所有元素类型相同，这使得操作更快，NumPy的ndarray更适合数学运算和科学计算。
   - pandas的DataFrame更适合处理表格型数据，特别是当你需要不同类型的数据或带标签的数据时。

实际上，pandas的DataFrame在内部使用了NumPy的ndarray。你可以把DataFrame看作是在ndarray基础上增加了更多功能的数据结构。

以下是从本教程中提取的 **pandas 高频 API cheatsheet**，按主题分类汇总，方便查阅学习：

## Pandas 高频 API Cheatsheet（按功能分类）

### 🧱 数据结构创建

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 创建 Series      | `pd.Series([1, 2, 3])`              | 创建一维数组                  |
| 创建 DataFrame   | `pd.DataFrame({'A':[1,2],'B':[3,4]})`| 创建二维表格结构              |

### 📂 数据导入导出

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 读取 CSV         | `pd.read_csv('file.csv')`           | 从 CSV 文件读取               |
| 写入 CSV         | `df.to_csv('file.csv', index=False)`| 保存为 CSV 文件               |

### 🔍 数据选择与筛选

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 按标签选择       | `df.loc['a', 'A']`                  | 按索引和列名选择              |
| 按位置选择       | `df.iloc[0, 1]`                     | 按整数位置选择                |
| 切片选择         | `df.loc['a':'c',['A', 'B']]`       | 标签范围选择子集              |
| 布尔筛选         | `df[df['A']> 10]`                  | 条件筛选行                    |

### ✏️ 常见列操作

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 添加新列         | `df['C']= df['A']+ df['B']`       | 基于现有列计算新列            |
| 删除列           | `df.drop(columns=['B'])`            | 删除指定列                    |
| 重命名列         | `df.rename(columns={'A':'Alpha'})`  | 修改列名                      |
| 排序行           | `df.sort_values(by='A', ascending=False)` | 按列排序                   |
| 唯一值           | `df['A'].unique()`                  | 返回唯一值数组                |
| 值频统计         | `df['A'].value_counts()`            | 各唯一值出现次数              |

### ❓ 缺失值处理

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 检测缺失值       | `df.isnull()`                       | 返回布尔矩阵标记缺失位置      |
| 填充缺失值       | `df.fillna(0)`                      | 将缺失值替换为指定值          |
| 删除含缺失行     | `df.dropna()`                       | 删除包含任意 NaN 的行         |
| 删除全缺失行     | `df.dropna(how='all')`              | 删除整行都是 NaN 的行         |

### 📊 分组与聚合

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 分组             | `df.groupby('Category')`            | 按某列分组                    |
| 聚合求和         | `df.groupby('Category')['Value'].sum()` | 每组求和                    |
| 聚合平均         | `df.groupby('Category')['Value'].mean()`| 每组平均值                 |
| 聚合计数         | `df.groupby('Category')['Value'].count()`| 每组元素个数              |

### 🔗 拼接与合并

|操作|行数变化|列数变化|键的保留范围|常见用途|
|---|---|---|---|---|
|`concat` (纵向)|行 +=|列 =|不看键|把同结构数据分批汇总|
|`merge`-inner|≤|= 或 +|**交集**|只要双方都有的记录|
|`merge`-outer|≥|= 或 +|**并集**|全量对齐，后续清洗|

> 若想只保留左表全部行，用 `how='left'`；
> 只保留右表全部行，用 `how='right'`。

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 行拼接（concat）| `pd.concat([df1, df2], ignore_index=True)` | 沿 axis=0 合并             |
| 合并（merge）| `pd.merge(df1, df2, on='key')`      | 类似 SQL 的 join 操作         |
| 外连接           | `pd.merge(df1, df2, on='key', how='outer')`| 包含所有键，缺失补 NaN    |

### 🔧 函数应用

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 应用于 Series     | `df['A'].apply(lambda x: x*2)`      | 对每个元素应用函数            |
| 字典映射         | `df['col'].map({'A':1, 'B':2})`     | 将值映射为其他值              |
| 按行 apply       | `df.apply(func, axis=1)`            | 将函数作用于每行（Series）|

### 🧪 类型转换

| 功能      | API 示例                           | 说明              |
| ------- | -------------------------------- | --------------- |
| 改数据类型   | `df['A'].astype(float)`          | 强制类型转换          |
| 转换为日期时间 | `pd.to_datetime(df['date_str'])` | 字符串解析为 datetime |

### ⏱️ 时间序列操作

| 功能             | API 示例                            | 说明                          |
|------------------|-------------------------------------|-------------------------------|
| 创建日期索引     | `pd.date_range('2021-01-01', periods=10)` | 生成日期序列             |
| 设置为时间索引   | `df.index = pd.to_datetime(df['date'])` | 指定为时间索引           |
| 时间重采样       | `df.resample('M').sum()`            | 以月份为单位汇总             |
