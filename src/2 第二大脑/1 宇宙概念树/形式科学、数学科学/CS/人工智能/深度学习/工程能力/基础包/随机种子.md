---
date created: 2025-05-02
date modified: 2025-07-10
uid: 75a08df0-bd6c-45a1-a330-22a33f230b5d
---

就像骰子，表面随机，但是我只要给一样的暗号（种子），一样的手法，就可以保证每次摇的结果都一样。

___

没错，你的比喻相当贴切——**随机种子 ≈ 给骰子的“暗号 + 手法”，让“看似随机”的过程变成可复演的魔术**。下面把这个类比拆解一下，顺便指出真实骰子与程序里伪随机数的差别。

|过程|真实骰子|伪随机数发生器 (PRNG)|
|---|---|---|
|**内部机制**|受力、空气阻力、桌面摩擦等连续力学方程；本质仍是经典物理的 _确定性_ 系统，只是参数太多、对人而言“混沌”|纯粹的数学公式：给定一个内部状态，再通过位运算、乘加、移位等得到下一个数字|
|**“暗号/种子”**|初始位置、姿态、手腕抛掷角度、空气流速… **如果**能 100% 重现，骰子落点就 100% 相同|`seed` 就是 PRNG 的完整初始状态（或能唯一推导内部状态的数字）|
|**可复现性**|理论可行、实践几乎做不到；任何微小扰动都会放大|完全可行：同算法 + 同 seed ⇒ 序列绝对一致|
|**可预测性**|旁观者只能通过高帧摄像机 + 物理模型才有机会预测|只要知道算法 & seed，就能一步不漏算出后续数字 → 加密场景要避免|
|**随机性评估**|以物理不可控性为保障；不合格的骰子会偏重|需要统计测试（NIST, Dieharder 等）验证序列“像随机”|

## 关键点 1：**“看起来随机” ≠ “真正不可预测”**

- 真·随机（硬件噪声、量子退相干、熵池）
    初始状态对外不可知 → 无法精确复演，也无法提前推算。
    
- 伪随机（Mersenne Twister、XorShift 等）
    数学确定性 + 种子可控 → 仅仅“长得像”随机，但本质是算法函数。
    

## 关键点 2：为什么实验/机器学习要固定种子？

1. **复现实验**
    
    - 论文复现 / A/B 测试：换台机器跑，得到一模一样的模型初始权重、数据打乱顺序等。
        
2. **对比算法**
    
    - 只想看模型差异，不想让“随机初始化”这种噪声干扰统计显著性。
        
3. **调试排错**
    
    - 出现诡异 bug 时，把随机因素冻结，方便复现和单步追踪。
        

## 关键点 3：何时不要暴露或固定种子？

- **加密、彩票、密钥生成**：
    
    - 攻击者若拿到种子，后续“随机”全被剧透。
        
    - 要用硬件随机数或系统熵池 (`os.urandom()`、`/dev/urandom`、TPM) 并立即丢弃种子。
        
- **在线博弈、抽奖**：
    
    - 需要保证每局独立且不可预测，一般把种子设成时间戳 + 真随机熵，再哈希混合。
        

---

## 小结

> **随机种子** = 给伪随机算法一个“起跑姿势”。
>
> - 同种子 → 结果一模一样（像你每次都以同角度同力度掷骰）
>
> - 种子不同 → 结果路径完全改变
>
>
> 对科研与调试，它是“复制魔术”的好帮手；  
> 对安全与博弈，它又是“泄底牌”的潜在风险，需要真随机来护航。
