---
aliases: [Kafka 在跨系统数据同步中的应用]
draw:
title: Kafka 在跨系统数据同步中的应用
linter-yaml-title-alias: Kafka 在跨系统数据同步中的应用
date created: 2025-02-15
date modified: 2025-02-15
---

Kafka 在跨系统数据同步中的应用主要体现在其数据一致性和同步机制，尤其是 "double fetch" 方式对数据同步的启发。

我会研究 Kafka 在跨系统数据同步中的具体实现方式，包括：

- **数据一致性**：Kafka 如何保证数据在不同系统间的一致性。
- **double fetch 机制**：这个机制如何提升数据同步的可靠性和一致性。
- **实践应用**：如何利用 Kafka 的这些特性优化跨系统数据同步，比如数据复制、事务保证、Exactly-Once 语义等。

我会整理这些内容，并提供可行的技术启发，帮助你更好地应用到日常的数据同步业务中。我会尽快给你反馈！

## Kafka 在跨系统数据同步中的应用

在现代分布式架构中，跨系统的数据同步需要高可靠性和一致性。Kafka 作为分布式流处理平台，以其高吞吐、可扩展和容错的特性，常被用于充当数据同步的中间件 ([Kafka在美团数据平台的实践 - 美团技术团队](https://tech.meituan.com/2022/08/04/the-practice-of-kafka-in-the-meituan-data-platform.html#:~:text=%E5%A6%82%E5%9B%BE1))。下面将从数据一致性保障、"double fetch"机制、实践案例和架构启发四方面详细解析 Kafka 在跨系统数据同步中的作用。

### 数据一致性保障

Kafka 提供多种机制来确保跨系统数据同步过程中的数据一致性 ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=Kafka%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%BC%BA%E8%B0%83%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%EF%BC%8C%E4%BD%86%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E7%A1%AE%E4%BF%9D%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E6%8C%87%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9%E4%B8%8A%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%EF%BC%8C%E4%B8%8D%20%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%88%96%E9%94%99%E4%B9%B1%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E5%9C%A8Kafka%E4%B8%AD%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E9%80%9A%E8%BF%87%E5%A4%9A%E4%B8%AA%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E3%80%81ISR%EF%BC%88In))：

- **Leader-Follower 复制与 ACK 机制**：Kafka 的每个分区采用主从复制模型。Producer 只将消息发送给分区的 Leader 副本，Leader 将消息追加到本地日志后，各 Follower 副本会主动向 Leader 发送拉取请求获取数据并按相同顺序写入各自日志 ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=1,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82))。Follower 完成写入后向 Leader 发送 ACK，Leader 收到所有同步副本（ISR）**的 ACK 后，更新高水位（HW），认为消息已提交**，再向 Producer 确认成功 ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=1,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82))。这种机制保证消息被至少多个节点持久化，避免单点故障导致数据丢失。在 Leader 收到所有 ISR 副本确认前，消息不会被视为"提交"，消费者也不可见，从而保证只有已同步的消息才能对外提供读取，确保跨节点的一致性 ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=Leader%20%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E3%80%82%203,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82))。
    
- **ISR（同步副本集合）机制**：Kafka 为每个分区维护一个 ISR 列表，包含了跟上 Leader 进度的所有 Follower ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=2.%20ISR%EF%BC%88In))。如果某个 Follower 落后超过阈值，则被临时移出 ISR，只有重新追上才能再加入 ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=2.%20ISR%EF%BC%88In))。**ISR 机制确保只有与主副本同步良好的副本才能参与数据读写**，防止落后副本提供过期数据 ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=2.%20ISR%EF%BC%88In))。当 Leader 故障时，只从 ISR 中选择新的 Leader，以保证新 Leader 拥有所有已提交的数据，不会出现已提交数据丢失或不一致的情况。
    
- **事务与 Exactly-Once 语义**：Kafka 从 0.11+ 版本引入事务机制，提供端到端的**Exactly-Once（精确一次）语义**。Producer 可以启用幂等特性和事务，将**消息发送和偏移提交合并在同一个原子事务中** ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=5))。一旦事务提交成功，表示消息已成功写入 Kafka，且对应的消费位移也提交完成，保证了下游消费者不会重复处理或漏处理消息 ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=5))。其实现原理是 Kafka 内部的事务协调器（TransactionCoordinator）采用两阶段提交协议，将跨分区的多条消息作为一个原子单元写入，并利用内部特殊主题保存事务状态，实现提交或中止的原子性 ([Replication（下）：事务，一致性与共识 - 美团技术团队](https://tech.meituan.com/2022/08/25/replication-in-meituan-02.html#:~:text=%E8%80%8C%E9%92%88%E5%AF%B9%E9%83%A8%E5%88%86%E5%A4%B1%E6%95%88%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8C%E5%9C%A8%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E6%97%B6%EF%BC%8Ckafka%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%A4%96%E5%8C%85%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E8%80%8C%E8%A8%80%EF%BC%8C%E6%89%98%E7%AE%A1%E7%BB%99Controller%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%94%B1%E5%85%B6%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%BB%E5%89%AF%E6%9C%AC%E3%80%82%E8%80%8C%E5%AF%B9%E4%BA%8EContro%20ller%E8%8A%82%E7%82%B9%E6%9C%AC%E8%BA%AB%EF%BC%8C%E5%88%99%E5%B0%86%E8%BF%99%E4%B8%AA%E8%81%8C%E8%B4%A3%E6%89%98%E7%AE%A1%E7%BB%99%E4%BA%86%E5%A4%96%E9%83%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8ZK%EF%BC%8C%E5%88%A9%E7%94%A8ZK%E6%8F%90%E4%BE%9B%E7%9A%84%E9%94%81%E4%BA%8E%E7%A7%9F%E7%BA%A6%E6%9C%8D%E5%8A%A1%E5%B8%AE%E5%8A%A9%E5%AE%9E%E7%8E%B0%E5%85%B1%E8%AF%86%E4%BB%A5%E8%BE%BE%E6%88%90%E4%B8%BB%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE%EF%BC%8C%E8%80%8C%E5%9C%A8%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%AD%EF%BC%8CKafka%E5%8E%BB%E6%8E%89%E4%BA%86%E5%A4%96%E9%83%A8%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%8D%E5%8A%A1%EF%BC%8C%20%E8%80%8C%E8%BD%AC%E8%80%8C%E8%87%AA%E5%B7%B1%E7%94%A8%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Controller%E9%80%89%E4%B8%BB%EF%BC%8C%E5%90%8C%E6%97%B6%E5%85%83%E6%95%B0%E6%8D%AE%E4%B9%9F%E7%94%B1%E5%8E%9F%E6%9D%A5%E4%BE%9D%E8%B5%96ZK%E5%8F%98%E4%B8%BA%E8%87%AA%E4%B8%BB%E7%9A%84Kraft%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96%E5%AD%98%E5%82%A8%E8%BF%9B%E8%A1%8C%E8%87%AA%E6%B2%BB%E3%80%82))。通过 **幂等性**（Idempotent Producer）和**事务**，Kafka 可避免由于重试而产生的重复数据，做到消息"不丢不重" ([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%EF%BC%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%2Back%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E3%80%82)) ([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=0))。需要注意 Exactly-Once 在 Kafka 内部或 Kafka->Kafka 流水线中可以保证，但对于输出到外部系统的场景，则往往需要结合目标端的幂等设计来实现（见下文实践案例）。
    

上述机制共同保障了 Kafka 在跨系统同步场景下的数据一致性和可靠性。例如，当开启 `acks=all`（所有ISR确认）时，Kafka 可以确保消息至少被一个以上副本持久化后再确认，从而在 broker 崩溃时已提交的数据依然可从其他副本获取，不会丢失 ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=Leader%20%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E3%80%82%203,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82))。同时，只有所有同步副本都有的数据才会被消费者读取，保证不同消费节点读取到的数据一致 ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=Kafka%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%BC%BA%E8%B0%83%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%EF%BC%8C%E4%BD%86%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E7%A1%AE%E4%BF%9D%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E6%8C%87%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9%E4%B8%8A%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%EF%BC%8C%E4%B8%8D%20%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%88%96%E9%94%99%E4%B9%B1%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E5%9C%A8Kafka%E4%B8%AD%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E9%80%9A%E8%BF%87%E5%A4%9A%E4%B8%AA%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E3%80%81ISR%EF%BC%88In))。如果需要更严格的语义，事务功能可确保跨分区、多步骤的同步过程具有原子性，一致性更强。

### "Double Fetch" 机制解析

**"Double Fetch" 机制**指的是 Kafka 中数据被"双重拉取"的过程：一次在集群内部进行副本同步，另一次由消费者拉取用于下游处理。虽然这是 Kafka 内部设计的自然结果，但从数据同步角度看，这种"双重获取"对提高可靠性至关重要：

- **副本拉取（Follower Fetch）**：正如前述，Follower 副本通过向 Leader **周期性发送 Fetch 请求**来拉取新消息 ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=%E5%B0%91%EF%BC%88%E4%B9%9F%E5%8D%B3%E8%AF%A5Partition%20%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%20Replica%EF%BC%89%EF%BC%8CProducer%20%E5%8F%AA%E5%B0%86%E8%AF%A5%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%88%B0%E8%AF%A5%20Partition,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82))。这一机制确保数据被复制到多个节点，即完成**第一次拉取**。只有在至少一个或一组 Follower 拉取并持久化了数据后（依据 ack 配置），Leader 才会确认消息，从而实现数据的冗余存储 ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=Leader%20%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E3%80%82%203,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82))。这一步相当于在系统内部进行了第一次数据"抓取"和分发，保证消息在跨节点一致可用。
    
- **消费者拉取（Consumer Fetch）**：Kafka 采用**拉模型（poll）**供消费者获取消息。消费者向 broker 发起 Fetch 请求，将已提交的消息批量拉取出来进行处理 ([Kafka数据同步原理详解 - CSDN博客](https://blog.csdn.net/a1774381324/article/details/133801048#:~:text=Kafka%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%20))。这是数据的**第二次拉取**。由于 Kafka 将消息持久化在日志中且复制到 ISR 副本，消费者无论何时拉取，都可以读到一致且持久的数据片段。即使目标系统（消费者）暂时不可用或处理缓慢，消息也已经可靠地存储在 Kafka 中，等待稍后被再次拉取消费。这种设计解耦了数据生产和消费：**第一次拉取保证消息可靠存储，第二次拉取保证消息可靠送达**。例如，在跨系统同步中，如果目标系统宕机，Kafka 中的数据仍完好无损，待其恢复后消费者可以从上次偏移继续拉取，不会因为中间停机而丢数据。
    
- **重复拉取与容错**："Double fetch"机制隐含地允许了**重复消费以保证不丢数据**。在实际应用中，如果消费者处理消息后发生崩溃但尚未提交偏移，那么这些消息在重启后会被再次拉取处理（即同一消息可能被获取两次）([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=%E5%B9%82%E7%AD%89%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%B0%86%E6%B6%88%E6%81%AF%E4%BB%8Ekafka%E6%B6%88%E8%B4%B9%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BF%9D%E5%AD%98%E5%88%B0hbase%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8id%E4%B8%BB%E9%94%AE%2B%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%8F%92%E5%85%A5%E6%88%90%E5%8A%9F%E5%90%8E%E6%89%8D%E5%BE%80%20kafka%20%E4%B8%AD%E6%8C%81%E4%B9%85%E5%8C%96%20offset%E3%80%82%E8%BF%99%E6%A0%B7%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%AD%E9%97%B4%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%8F%91%E7%94%9F%E6%8A%A5%E9%94%99%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%81%A2%E5%A4%8D%E5%90%8E%E9%83%BD%E4%BC%9A%E4%BB%8E%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%8C%81%E4%B9%85%E5%8C%96%20offset))。Kafka 的设计倾向于确保宁可重复也不遗漏，这实际上是**至少一次**投递语义的体现。这种"再拉取"保证了数据**最终不会遗漏**，提升了跨系统同步的可靠性。不过重复消费可能导致目标产生重复数据，因此需要在消费端做好幂等处理或利用 Kafka 提供的事务机制来避免副作用。
    

"Double fetch"机制在实现上体现在 Kafka 简洁的**存储-分发模型**：生产者将数据写入集中日志，Kafka 内部复制（第一次fetch），消费者从日志读取（第二次fetch）。**两次拉取使得数据传输更具韧性**：第一次保证了数据进入可靠存储介质，第二次确保数据从介质到消费端的过程可控可重试。对跨系统同步而言，这意味着我们可以安全地依赖 Kafka 作为中转，不必担心网络抖动或目标系统故障引起的数据丢失。总的来说，"double fetch"提供了"**存下再传出**"的双保险，提高了数据同步链路的可靠性。

### 实践中的数据同步案例

Kafka 已广泛应用于各类跨系统数据同步场景。下面结合实际案例，说明如何利用 Kafka 的机制来实现高效可靠的数据同步，并探讨数据复制、事务同步、分区策略等方面的实践。

- **日志/数据库变更分发**：大型互联网公司常用 Kafka 将源系统的数据分发到多个下游。例如，美团将**业务数据库的更新、日志等通过 Kafka 缓存并分发到离线数仓、实时计算、日志平台、OLAP 分析等不同系统**，构建企业级数据总线 ([Kafka在美团数据平台的实践 - 美团技术团队](https://tech.meituan.com/2022/08/04/the-practice-of-kafka-in-the-meituan-data-platform.html#:~:text=%E5%A6%82%E5%9B%BE1))。在该场景下，Kafka 作为**数据复制中心**：上游各业务产生的消息经 Kafka Topic 缓存后，下游多个消费者并行拉取各自所需的数据副本，实现**一份数据，多处同步**。由于 Kafka 的高吞吐设计（顺序磁盘写入、批量发送等）和分区并行特性，即使数据量巨大依然可以稳定传输。例如，美团数据平台 Kafka 集群每日处理30PB+的数据、峰值每秒4亿条消息 ([Kafka在美团数据平台的实践 - 美团技术团队](https://tech.meituan.com/2022/08/04/the-practice-of-kafka-in-the-meituan-data-platform.html#:~:text=Kafka%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%9A%84%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E6%80%BB%E4%BD%93%E6%9C%BA%E5%99%A8%E6%95%B0%E5%B7%B2%E7%BB%8F%E8%B6%85%E8%BF%87%E4%BA%8615000%2B%E5%8F%B0%EF%BC%8C%E5%8D%95%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%BA%E5%99%A8%E6%95%B0%E4%B9%9F%E5%B7%B2%E7%BB%8F%E5%88%B0%E4%BA%862000%2B%E5%8F%B0%E3%80%82%E5%9C%A8%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E4%B8%8A%EF%BC%8C%E5%A4%A9%E7%BA%A7%E6%B6%88%E6%81%AF%E9%87%8F%E5%B7%B2%E7%BB%8F%E8%B6%85%E8%BF%87%E4%BA%8630%2BP%EF%BC%8C%E5%A4%A9%E7%BA%A7%E6%B6%88%E6%81%AF%E9%87%8F%E5%B3%B0%20%E5%80%BC%E4%B9%9F%E8%BE%BE%E5%88%B0%E4%BA%864%2B%E4%BA%BF%2F%E7%A7%92%E3%80%82%E4%B8%8D%E8%BF%87%E9%9A%8F%E7%9D%80%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E7%9A%84%E5%A2%9E%E5%A4%A7%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A2%9E%E9%95%BF%EF%BC%8CKafka%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98%E4%B9%9F%E6%84%88%E5%8F%91%E4%B8%A5%E5%B3%BB%EF%BC%8C%E4%B8%8B%E9%9D%A2%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84%E6%8C%91%E6%88%98%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E3%80%82)), 展现了利用分区扩展吞吐的强大能力。通过恰当设置分区数和副本数，源数据可以被可靠地快速复制到各种异构系统中。
    
- **数据库到数据库的增量同步**：在传统数据库之间做实时同步时，Kafka 常被用作中间缓冲层。比如，将 MySQL 的更新通过 Kafka Connect 的 Debezium 捕获变更数据（CDC）写入 Kafka，再由下游 JDBC Sink Connector 或自定义消费者将数据写入另一个数据库或搜索引擎，实现跨库同步。**数据一致性**通过以下方式保障：上游 Debezium 作为 Producer 可开启 **幂等生产和事务**，确保每条变更事件在 Kafka 中仅存一次；下游消费者处理时**仅在写入目标成功后提交偏移**，若出现故障重启则 Kafka 会重发未提交的消息，从而避免数据丢失 ([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=%E5%B9%82%E7%AD%89%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%B0%86%E6%B6%88%E6%81%AF%E4%BB%8Ekafka%E6%B6%88%E8%B4%B9%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BF%9D%E5%AD%98%E5%88%B0hbase%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8id%E4%B8%BB%E9%94%AE%2B%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%8F%92%E5%85%A5%E6%88%90%E5%8A%9F%E5%90%8E%E6%89%8D%E5%BE%80%20kafka%20%E4%B8%AD%E6%8C%81%E4%B9%85%E5%8C%96%20offset%E3%80%82%E8%BF%99%E6%A0%B7%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%AD%E9%97%B4%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%8F%91%E7%94%9F%E6%8A%A5%E9%94%99%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%81%A2%E5%A4%8D%E5%90%8E%E9%83%BD%E4%BC%9A%E4%BB%8E%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%8C%81%E4%B9%85%E5%8C%96%20offset))。假如目标是 Elasticsearch 或 HBase 等支持幂等写入的系统，可以使用唯一主键（如 ID）作为去重依据，在消费端实现 upsert 写入——重复的事件会覆盖已存在记录，不会产生重复数据 ([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=%EF%BC%882%EF%BC%89%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%EF%BC%9A%E4%B8%BB%E8%A6%81%E5%80%9F%E5%8A%A9%E4%BA%8E%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9C%AC%E8%BA%AB%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E6%88%96%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E5%B9%82%E7%AD%89%E3%80%82%E5%A6%82%EF%BC%9Ahbase%20%E3%80%81elasticsearch%E5%B9%82%E7%AD%89%E3%80%82))。这种模式下，即使 Kafka 采用至少一次投递导致某些更新被消费两次，最终目标库的数据仍保持一致。**事务性同步**也可引入：如果需要同时同步多个表或分区的数据，Kafka Connect 提供了 Source 端的事务支持 (如 KIP-618) ([Exactly-once semantics with Kafka transactions](https://strimzi.io/blog/2023/05/03/kafka-transactions/#:~:text=for%20transactions%2C%20which%20provides%20exactly,618))使整个同步流程更加原子；或者应用层通过将相关多条消息打包在 Kafka 的单个事务中，再由下游一次性消费处理，确保跨表跨分区的数据变更要么全部成功要么全部失败。
    
- **分区策略的应用**：设计 Kafka 同步作业时，合理的**分区策略**有助于在保证顺序的同时提高吞吐量 ([Kafka Partition的同步策略_数据传输服务(DTS)-阿里云帮助中心](https://help.aliyun.com/zh/dts/user-guide/specify-the-policy-for-synchronizing-data-to-kafka-partitions#:~:text=%E5%9C%A8%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5%E5%88%B0%20Kafka%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%BD%9C%E4%B8%9A%E6%97%B6%EF%BC%8C%E4%B8%BA%E6%8F%90%E5%8D%87%E5%90%8C%E6%AD%A5%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%8C%E6%82%A8%E5%8F%AF%E4%BB%A5%E8%B0%83%E6%95%B4%20Kafka%20Partition%EF%BC%88%E5%88%86%E5%8C%BA%EF%BC%89%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%A0%B9%E6%8D%AE,Hash%20%E7%BB%93%E6%9E%9C%E5%B0%86%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%87%B3%E4%B8%8D%E5%90%8C%E7%9A%84%20Partition%E3%80%82))。如果要求严格的全局顺序一致，例如全量同步初始数据或要求按变更顺序处理所有事件，可以选择**将所有数据投递到单一分区**，这样 Kafka 天然保证分区内的顺序与源一致 ([Kafka Partition的同步策略_数据传输服务(DTS)-阿里云帮助中心](https://help.aliyun.com/zh/dts/user-guide/specify-the-policy-for-synchronizing-data-to-kafka-partitions#:~:text=%E5%85%A8%E9%83%A8%E6%8A%95%E9%80%92%E8%87%B3%20Partition%200))（所有消息序列化顺序不乱）；代价是只有一个分区处理，无法并行，性能有限 ([Kafka Partition的同步策略_数据传输服务(DTS)-阿里云帮助中心](https://help.aliyun.com/zh/dts/user-guide/specify-the-policy-for-synchronizing-data-to-kafka-partitions#:~:text=%E5%B0%86%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%92%8C%20DDL%20%E4%BF%A1%E6%81%AF%E9%83%BD%E6%8A%95%E9%80%92%E5%88%B0%E7%9B%AE%E6%A0%87%20Topic%20%E7%9A%84,Partition%200%E3%80%82))。对于更高的性能需求，常根据业务键做哈希将数据分散到多个分区。例如**按表名或主键哈希**来分区，同一表或相同主键的变更总是进入固定分区，从而保证了该粒度内的顺序，而不同表或不同主键的数据可以并行消费 ([Kafka Partition的同步策略_数据传输服务(DTS)-阿里云帮助中心](https://help.aliyun.com/zh/dts/user-guide/specify-the-policy-for-synchronizing-data-to-kafka-partitions#:~:text=%E5%B0%86%E5%BA%93%E5%90%8D%E4%B8%8E%E8%A1%A8%E5%90%8D%E5%90%88%E5%B9%B6%E4%BD%9C%E4%B8%BA%20Partition%20Key%20%E6%9D%A5%E8%AE%A1%E7%AE%97%20Hash,DDL%20%E4%BF%A1%E6%81%AF%E6%8A%95%E9%80%92%E5%88%B0%E7%9B%AE%E6%A0%87%20Topic%20%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%20Partition%E3%80%82))。这种策略在同步多个业务表时非常实用：单表内部顺序一致且高效并行，不同表的先后次序则交由业务逻辑处理。需要注意，一旦确定了分区策略和分区数，在同步任务期间不应随意更改目标 Topic 的分区数，否则会导致数据乱序或同步作业失败 ([Kafka Partition的同步策略_数据传输服务(DTS)-阿里云帮助中心](https://help.aliyun.com/zh/dts/user-guide/specify-the-policy-for-synchronizing-data-to-kafka-partitions#:~:text=%E8%AD%A6%E5%91%8A))。通过分区策略权衡顺序与吞吐，我们能根据同步业务需求设计出既保证关键数据有序又充分利用并行能力的方案。
    

上述案例表明，Kafka 可以胜任多种跨系统数据同步需求：无论是一对多的日志分发，还是数据库间的准实时同步，都能通过其强一致性的存储和灵活的消费模型来保证数据可靠送达。在实现过程中，结合 Kafka 的**事务特性**和目标系统的**幂等能力**，可以进一步确保精确一次的效果；而良好的**分区设计**则保证了同步的效率和顺序要求。通过这些实践经验，我们可以更深刻地理解如何在实际业务中利用 Kafka 搭建稳定、高效的数据同步流水线。

### 对日常数据同步业务的启发

Kafka 的机制为构建高可用、高吞吐的数据同步架构提供了诸多启发：

- **持久化日志与多副本**：将数据变化记录到持久化日志并复制到多个节点，是确保数据高可靠的关键。这类似于数据库的WAL(预写日志)和主从复制思想。Kafka 的成功表明，在系统间同步时引入一个持久消息日志，可极大提升容错性。即使发生部分系统故障，日志中已保存的消息仍可供恢复使用，从而保证各系统最终一致。这启发我们在设计数据同步时，可以使用类似 Kafka 的消息队列或日志系统作为缓冲，**以日志驱动同步**，并通过多副本防止单点失败。
    
- **解耦和弹性**：Kafka 通过发布/订阅模型将数据的生产与消费解耦，不同系统之间不直接耦合，而是通过 Kafka 中转。这样一来，源和目标系统可以独立扩展、独立容错。同步过程中若目标处理变慢，消息会暂存在 Kafka，不会阻塞源的运行；反之亦然。这种**松耦合架构**提高了整体系统的弹性和扩展性。在日常数据同步设计中，也应遵循解耦原则，引入中间缓冲队列/日志，平衡不同行系统的速度差异，提升峰值吞吐能力 ([Kafka在美团数据平台的实践 - 美团技术团队](https://tech.meituan.com/2022/08/04/the-practice-of-kafka-in-the-meituan-data-platform.html#:~:text=%E5%A6%82%E5%9B%BE1))。
    
- **事务和幂等**：分布式环境下实现端到端的 Exactly-Once 非常困难，但 Kafka 提供了在其内部实现事务的思路。对于跨系统同步，借鉴这一思路，可以在**关键环节保证原子性或幂等性**：要么利用 Kafka 本身的事务特性（比如将相关操作纳入一个事务性 Topic 写入），要么确保目标端写入操作是幂等的（如基于唯一键的更新）([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=%E5%B9%82%E7%AD%89%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%B0%86%E6%B6%88%E6%81%AF%E4%BB%8Ekafka%E6%B6%88%E8%B4%B9%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BF%9D%E5%AD%98%E5%88%B0hbase%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8id%E4%B8%BB%E9%94%AE%2B%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%8F%92%E5%85%A5%E6%88%90%E5%8A%9F%E5%90%8E%E6%89%8D%E5%BE%80%20kafka%20%E4%B8%AD%E6%8C%81%E4%B9%85%E5%8C%96%20offset%E3%80%82%E8%BF%99%E6%A0%B7%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%AD%E9%97%B4%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%8F%91%E7%94%9F%E6%8A%A5%E9%94%99%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%81%A2%E5%A4%8D%E5%90%8E%E9%83%BD%E4%BC%9A%E4%BB%8E%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%8C%81%E4%B9%85%E5%8C%96%20offset))。设计同步流程时，应明确每个环节的容错语义：哪一步可以重复执行、哪一步需要保证只执行一次，并利用事务协调或业务去重来满足这些语义。
    
- **水平扩展与高吞吐**：Kafka 依靠分区并行实现横向扩展，从而达到惊人的吞吐量 ([Kafka在美团数据平台的实践 - 美团技术团队](https://tech.meituan.com/2022/08/04/the-practice-of-kafka-in-the-meituan-data-platform.html#:~:text=Kafka%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%9A%84%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E6%80%BB%E4%BD%93%E6%9C%BA%E5%99%A8%E6%95%B0%E5%B7%B2%E7%BB%8F%E8%B6%85%E8%BF%87%E4%BA%8615000%2B%E5%8F%B0%EF%BC%8C%E5%8D%95%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%BA%E5%99%A8%E6%95%B0%E4%B9%9F%E5%B7%B2%E7%BB%8F%E5%88%B0%E4%BA%862000%2B%E5%8F%B0%E3%80%82%E5%9C%A8%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E4%B8%8A%EF%BC%8C%E5%A4%A9%E7%BA%A7%E6%B6%88%E6%81%AF%E9%87%8F%E5%B7%B2%E7%BB%8F%E8%B6%85%E8%BF%87%E4%BA%8630%2BP%EF%BC%8C%E5%A4%A9%E7%BA%A7%E6%B6%88%E6%81%AF%E9%87%8F%E5%B3%B0%20%E5%80%BC%E4%B9%9F%E8%BE%BE%E5%88%B0%E4%BA%864%2B%E4%BA%BF%2F%E7%A7%92%E3%80%82%E4%B8%8D%E8%BF%87%E9%9A%8F%E7%9D%80%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E7%9A%84%E5%A2%9E%E5%A4%A7%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A2%9E%E9%95%BF%EF%BC%8CKafka%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98%E4%B9%9F%E6%84%88%E5%8F%91%E4%B8%A5%E5%B3%BB%EF%BC%8C%E4%B8%8B%E9%9D%A2%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84%E6%8C%91%E6%88%98%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E3%80%82))。这提醒我们，在数据同步场景下，**水平扩展架构**是支撑海量数据交换的有效手段。可以通过对同步任务进行分片、并行处理不同数据分区来提高效率。同时，也要结合业务特点设置合理的分区键，避免数据倾斜和热点，以充分利用集群资源。
    
- **监控和故障恢复**：Kafka 内部通过 ISR 等机制自动感知副本滞后并进行处理，这启示我们在构建同步系统时也需要完善的监控和自动恢复策略。比如监控同步延迟、失败率，发现异常及时告警；借鉴 Kafka **高水位**概念，可设定检查点确保只处理已安全存储的变更；发生故障时，可从最近的稳定同步点继续，减少人工干预，实现自愈能力。
    

总而言之，Kafka 在跨系统数据同步中的应用展示了**构建健壮数据管道的最佳实践**：利用持久化日志保证数据不丢不重，利用复制和分区实现高可用和横向扩展，通过事务和幂等确保一致性，通过解耦提高弹性和吞吐。正是这些设计，使得 Kafka 在大规模数据同步中表现出色 ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E7%A1%AE%E4%BF%9D%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82%E9%80%9A%E8%BF%87%E5%90%8C%E6%AD%A5%E6%89%80%E6%9C%89%E5%89%AF%E6%9C%AC%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%81%E7%BB%B4%E6%8A%A4%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%94%AF%E6%8C%81%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E6%93%8D%E4%BD%9C%EF%BC%8CKafka%E5%9C%A8%E4%B8%8D%E7%89%BA%E7%89%B2%E6%80%A7%E8%83%BD%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E5%AE%9E%E7%8E%B0%E4%BA%86%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%82%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7%E4%BD%BFK%20afka%E6%88%90%E4%B8%BA%E5%A4%84%E7%90%86%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%90%86%E6%83%B3%E5%B7%A5%E5%85%B7%E3%80%82))。我们可以将这些理念运用到日常的数据同步业务中，设计出高可靠、高性能的同步架构，满足不断增长的跨系统数据交换需求。

**参考文献：**

1. JinYD2018, _"kafka 副本数据同步原理和数据丢失解决方案"_, CSDN博客 ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=1,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82)) ([kafka 副本数据同步原理和数据丢失解决方案_kafka节点之间数据不一致的问题-CSDN博客](https://blog.csdn.net/weixin_43281498/article/details/124310409#:~:text=Leader%20%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E3%80%82%203,HighWatermark%29%20%E5%B9%B6%E4%B8%94%E5%90%91%20Producer%20%E5%8F%91%E9%80%81%20ACK%E3%80%82))
2. 土木林森, _"Kafka 数据一致性原理"_, 阿里云开发者社区 ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=2.%20ISR%EF%BC%88In)) ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=5))
3. guoyu1, _"Kafka保证精确一次消费"_, 博客园 ([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=%E5%B9%82%E7%AD%89%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%B0%86%E6%B6%88%E6%81%AF%E4%BB%8Ekafka%E6%B6%88%E8%B4%B9%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BF%9D%E5%AD%98%E5%88%B0hbase%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8id%E4%B8%BB%E9%94%AE%2B%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%8F%92%E5%85%A5%E6%88%90%E5%8A%9F%E5%90%8E%E6%89%8D%E5%BE%80%20kafka%20%E4%B8%AD%E6%8C%81%E4%B9%85%E5%8C%96%20offset%E3%80%82%E8%BF%99%E6%A0%B7%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%AD%E9%97%B4%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%8F%91%E7%94%9F%E6%8A%A5%E9%94%99%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%81%A2%E5%A4%8D%E5%90%8E%E9%83%BD%E4%BC%9A%E4%BB%8E%E4%B8%8A%E4%B8%80%E6%AC%A1%E6%8C%81%E4%B9%85%E5%8C%96%20offset)) ([kafka保证精确一次消费 - guoyu1 - 博客园](https://www.cnblogs.com/guoyu1/p/12023264.html#:~:text=%EF%BC%882%EF%BC%89%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%EF%BC%9A%E4%B8%BB%E8%A6%81%E5%80%9F%E5%8A%A9%E4%BA%8E%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%9C%AC%E8%BA%AB%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E6%88%96%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E5%B9%82%E7%AD%89%E3%80%82%E5%A6%82%EF%BC%9Ahbase%20%E3%80%81elasticsearch%E5%B9%82%E7%AD%89%E3%80%82))
4. 阿里云数据传输服务文档, _"Kafka Partition 同步策略说明"_ ([Kafka Partition的同步策略_数据传输服务(DTS)-阿里云帮助中心](https://help.aliyun.com/zh/dts/user-guide/specify-the-policy-for-synchronizing-data-to-kafka-partitions#:~:text=%E5%85%A8%E9%83%A8%E6%8A%95%E9%80%92%E8%87%B3%20Partition%200)) ([Kafka Partition的同步策略_数据传输服务(DTS)-阿里云帮助中心](https://help.aliyun.com/zh/dts/user-guide/specify-the-policy-for-synchronizing-data-to-kafka-partitions#:~:text=%E5%B0%86%E5%BA%93%E5%90%8D%E4%B8%8E%E8%A1%A8%E5%90%8D%E5%90%88%E5%B9%B6%E4%BD%9C%E4%B8%BA%20Partition%20Key%20%E6%9D%A5%E8%AE%A1%E7%AE%97%20Hash,DDL%20%E4%BF%A1%E6%81%AF%E6%8A%95%E9%80%92%E5%88%B0%E7%9B%AE%E6%A0%87%20Topic%20%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%20Partition%E3%80%82))
5. 美团技术团队, _"Kafka 在美团数据平台的实践"_, 美团技术博客 ([Kafka在美团数据平台的实践 - 美团技术团队](https://tech.meituan.com/2022/08/04/the-practice-of-kafka-in-the-meituan-data-platform.html#:~:text=%E5%A6%82%E5%9B%BE1)) ([Kafka在美团数据平台的实践 - 美团技术团队](https://tech.meituan.com/2022/08/04/the-practice-of-kafka-in-the-meituan-data-platform.html#:~:text=Kafka%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%9A%84%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E6%80%BB%E4%BD%93%E6%9C%BA%E5%99%A8%E6%95%B0%E5%B7%B2%E7%BB%8F%E8%B6%85%E8%BF%87%E4%BA%8615000%2B%E5%8F%B0%EF%BC%8C%E5%8D%95%E9%9B%86%E7%BE%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%BA%E5%99%A8%E6%95%B0%E4%B9%9F%E5%B7%B2%E7%BB%8F%E5%88%B0%E4%BA%862000%2B%E5%8F%B0%E3%80%82%E5%9C%A8%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E4%B8%8A%EF%BC%8C%E5%A4%A9%E7%BA%A7%E6%B6%88%E6%81%AF%E9%87%8F%E5%B7%B2%E7%BB%8F%E8%B6%85%E8%BF%87%E4%BA%8630%2BP%EF%BC%8C%E5%A4%A9%E7%BA%A7%E6%B6%88%E6%81%AF%E9%87%8F%E5%B3%B0%20%E5%80%BC%E4%B9%9F%E8%BE%BE%E5%88%B0%E4%BA%864%2B%E4%BA%BF%2F%E7%A7%92%E3%80%82%E4%B8%8D%E8%BF%87%E9%9A%8F%E7%9D%80%E9%9B%86%E7%BE%A4%E8%A7%84%E6%A8%A1%E7%9A%84%E5%A2%9E%E5%A4%A7%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A2%9E%E9%95%BF%EF%BC%8CKafka%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98%E4%B9%9F%E6%84%88%E5%8F%91%E4%B8%A5%E5%B3%BB%EF%BC%8C%E4%B8%8B%E9%9D%A2%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84%E6%8C%91%E6%88%98%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E3%80%82))
6. Federico Valeri, _"Exactly-once semantics with Kafka transactions"_, Strimzi Blog ([Exactly-once semantics with Kafka transactions](https://strimzi.io/blog/2023/05/03/kafka-transactions/#:~:text=for%20transactions%2C%20which%20provides%20exactly,618)) ([Exactly-once semantics with Kafka transactions](https://strimzi.io/blog/2023/05/03/kafka-transactions/#:~:text=Transactions%20provide%20the%20guarantee%20of,and%20avoiding%20any%20data%20loss))
7. Jay Kreps, _"Exactly-Once Semantics are Possible: Here's How Apache Kafka Does It"_, Confluent Blog ([Exactly-once semantics with Kafka transactions](https://strimzi.io/blog/2023/05/03/kafka-transactions/#:~:text=When%20the%20idempotent%20producer%20is,of%20the%20sequence%20number%20per)) ([Exactly-once semantics with Kafka transactions](https://strimzi.io/blog/2023/05/03/kafka-transactions/#:~:text=Unfortunately%2C%20the%20idempotent%20producer%20does,this%20case%2C%20you%20can%20make)) (提及 Kafka 幂等生产者和事务原理)
8. Juejin社区, _"Kafka 副本同步机制"_ (参考Kafka数据同步原理及ISR机制解释) ([〖Kafka〗Kafka 数据一致性原理-阿里云开发者社区](https://developer.aliyun.com/article/1476727#:~:text=Kafka%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%BC%BA%E8%B0%83%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E5%92%8C%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%EF%BC%8C%E4%BD%86%E5%90%8C%E6%97%B6%E4%B9%9F%E8%A6%81%E7%A1%AE%E4%BF%9D%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E6%8C%87%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9%E4%B8%8A%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%EF%BC%8C%E4%B8%8D%20%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E3%80%81%E9%87%8D%E5%A4%8D%E6%88%96%E9%94%99%E4%B9%B1%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E5%9C%A8Kafka%E4%B8%AD%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E9%80%9A%E8%BF%87%E5%A4%9A%E4%B8%AA%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5%E3%80%81ISR%EF%BC%88In))
