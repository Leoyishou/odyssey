---
date created: 2025-05-02
date modified: 2025-07-10
uid: 5dfb4ee3-5408-419d-8f4c-56e071f3d0f7
---
## 工作流程示意

```Java
原始序列  ─► 取最近 N 点 ─► 排序 ─► 取第 p% 位置的值 = rolling quantile
                 ↑                        │
   每来新点就滑窗◄───────────────────────────┘
```


## 什么是 *rolling quantile*（滑动分位数）？

| 关键词 | 含义 |
|--------|------|
| **Quantile（分位数）** | 把一批数据从小到大排序后，处在 *p* 百分位位置的值；常见如中位数（50 th percentile）、P90、P95 等。|
| **Rolling / Sliding Window（滑动窗口）** | 只取最近 *N *个观测值，而不是整段历史；窗口每来一条新数据就向前滑动一格。|
| **Rolling Quantile（滑动分位数）** | 对“最近 N 个样本”计算分位数，再随着时间滚动不断更新。它给出的**阈值是动态的**，能跟着数据本身的趋势、波动及时调整。|

---

### 为什么要用它？

1. **动态阈值**  
   - 固定阈值容易在高峰期狂报警、低谷期漏报警。
   - 用滑动窗口里的 P95/P99 做阈值，可以自动适应当前水平。

2. **对异常更敏感**  
   - 分位数对极端值不敏感（相比均值+σ）；把异常点本身踢出阈值计算范围，更容易把下一次异常揪出来。

3. **实现简单、无模型依赖**  
   - 在监控、风控、数据库延迟告警等场景常当“自适应基线”的第一步。

---

### 示例：pandas 里三行搞定

```python
import pandas as pd

# 假设 ts 是按分钟采样的序列
ts = pd.Series([...], index=...)       # e.g. CPU 使用率

window   = 60                         # 60 分钟窗口
p        = 0.95                       # 95 分位
threshold = ts.rolling(window).quantile(p)

alerts = ts > threshold               # 动态报警判定
```

> `rolling().quantile()` 内部会在窗口滑动时重新排序并取分位，所以阈值实时更新。

---

### 选型&注意事项

| 关注点 | 建议 |
|---------|------|
| **窗口大小 (N)** | 太小→阈值抖动；太大→跟不上趋势。常用 1–3 倍典型周期（如 1 天 PV 就用最近 1–3 天）。|
| **百分位 (p)** | 衡量允许的“正常尖峰”比例。常见 P90~P99；业务对异常容忍度越低，p 设得越低。|
| **性能** | 全表重排序 O(N log N)。流式高频数据可用 *t-digest*、Greenwald-Khanna 等**近似分位算法**。|
| **节假日/季节性** | 如果节假日行为截然不同，可分场景分别维护 rolling quantile，或先做周期剔除再算。|
| **与其他指标配合** | 常把 rolling quantile 当作“基线”阈值，再叠加固定下限、同比／环比等多维规则。|

---

## 小结

- **rolling quantile = 滑动窗口 + 分位数**  
- 作用：**给数据流提供自适应、抗极值的动态阈值**，在监控告警、异常检测、风控限额等场景非常实用。
- 关键是窗口长度和百分位配置；如遇高频海量数据可用近似算法减轻计算压力。
