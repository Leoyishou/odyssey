---
draw:
title: 异常处理 9
tags: [1 Dev, Java, 代码味道, 信息革命]
date created: 2024-04-17
date modified: 2024-12-27
---

excerpt

<!-- more -->

1.【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。

> 说明：catch (NullPointerException e) 的也真是人才

2.【强制】异常捕获后不要用来做流程控制，条件控制。

> 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。
>    1. **异常处理机制的设计和开销**：异常处理机制设计用于处理程序执行中的异常情况，例如错误或不可预测的事件。当一个异常被抛出时，程序执行流会跳出正常的执行路径，进入一个为异常处理专门设定的路径。这个过程涉及到保存当前执行状态、停止当前任务、然后跳转到异常处理代码。这些步骤本身就比简单的条件判断（例如一个 `if` 语句）要复杂和耗时得多。
    1. **栈解卷（Stack Unwinding）**：在许多编程语言中，抛出异常时，系统需要进行栈解卷，即回溯调用栈直到找到相应的异常处理代码。这个过程涉及到很多操作，如调用栈的回溯、资源的清理等。这些操作在资源和时间上的消耗都比简单的条件判断大。
    2. **代码可预测性和优化难度**：编译器和解释器通常能够优化常规的条件判断语句，因为这些是程序流中的预期路径。然而，异常处理通常被视为 " 异常路径 "，编译器可能难以为这些路径进行有效的优化。
    3. **资源和内存使用**：异常处理经常涉及到额外的资源和内存使用，例如为异常对象分配内存。在抛出和捕获异常的过程中，可能还需要创建和处理额外的信息（如异常消息和堆栈跟踪信息），这些都是额外的开销。

3.【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。

> catch 的粒度要尽可能小

4.【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

> springweb 中最后那一层异常处理的切面

5.【强制】事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。

6.【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。

7.【强制】不要在 finally 块中使用 return

8.【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。

9.【强制】在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常使用 Throwable 类进行拦截。

> 这个比较高阶了

11.【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：
	1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE  
	   反例：public int method() { return Integer 对象; }，如果为 null，自动解箱抛 NPE。
	2）数据库的查询结果可能为 null。
	3）集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。
	4）远程调用返回对象时，一律要求进行空指针判断，防止 NPE。
	5）对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。
	6）级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。
	   正例：使用 JDK8 的 Optional 类来防止 NPE 问题。

> Optional 已经用的比较熟练了

13.【参考】对于公司外的 http / api 开放接口必须使用错误码，而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess() 方法、错误码、错误简短信息；应用内部推荐异常抛出。
	说明：关于 RPC 方法返回方式使用 Result 方式的理由：
	1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。
	2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。
	如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。

> 北极星的 ApiResult 包括 errcode、errmsg、data

1.【强制】错误码的制定原则：快速溯源、沟通标准化。

> 废话

2.【强制】错误码不体现版本号和错误等级信息。

3.【强制】全部正常，但不得不填充错误码时返回五个零：00000。

> 北极星中直接没 set，errCode 应该是 null

4.【强制】错误码为字符串类型，共 5 位，分成两个部分：错误产生来源 + 四位数字编号。

> 北极星中用的三位，且第一位没统一成来源

5.【强制】编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。

6.【强制】错误码使用者避免随意定义新的错误码。

7.【强制】错误码不能直接输出给用户作为提示信息使用。
