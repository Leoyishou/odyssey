---
draw:
tags: []
title: OOP-Klass Model
date created: 2024-11-30
date modified: 2024-12-27
---

让我用简单的话解释：

想象你有一个玩具盒子(这就是Java对象)。这个盒子分两部分：

1. 盒子本身(OOP部分)
- 盒子上的标签(对象头): 写着这是谁的盒子、盒子是否被别人借走等信息
- 里面装的玩具(实例数据): 就是你的玩具

1. 说明书(Klass部分)
- 放在别的地方(方法区)
- 告诉你这个玩具怎么玩
- 所有相同的玩具共用一本说明书

比如你买了一个乐高玩具:

- 盒子里装着乐高积木(实例数据)
- 盒子上有标签(对象头)说这是你的
- 说明书(Klass)告诉你怎么拼装，所有买这款乐高的小朋友都用同一本说明书

这样设计可以省空间，因为不用给每个玩具都配一本说明书。

是的,[[享元模式]]和JVM的OOP-Klass设计很相似。两者都把对象分成:

1. 内部状态(不变的,可共享)

- 享元模式: 内部属性
- JVM: Klass(类信息,方法等)

1. 外部状态(变化的,不共享)

- 享元模式: 外部属性
- JVM: OOP(对象实例数据)

这样的设计都能节省内存,提高系统性能。

文章主要介绍了Java对象在JVM中的存储模型(OOP-Klass Model)的核心概念：

1. 基本结构
- OOP (Ordinary Object Pointer): 表示对象实例数据
- Klass: 描述对象的类型信息
- 每个Java对象包含对象头、实例数据和对齐填充

1. 对象头包含：
- Mark Word: 存储锁状态、GC标记等信息
- 类元数据地址: 指向对象类型信息

1. OOP-Klass设计原因：
- 避免每个对象都包含虚函数表
- 将对象实例数据(OOP)和类型信息(Klass)分离
- 实现Java的多态机制

1. instanceKlass作用：
- 在JVM中表示Java类
- 包含方法列表、接口、字段、常量池等类信息
- 存储在方法区中

这种设计让JVM可以统一管理内存分配和回收，同时有效实现了Java的面向对象特性。
