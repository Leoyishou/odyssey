---
draw: 
title: CS@
date created: 2024-05-19
date modified: 2025-02-15
---

外表高大上，看着是宾利的壳，其实核心动力是几个老鼠在壳里面蹬三轮呢。只要你干一两年基本都懂了。

[胡适](胡适.md)说：怕什么真理无穷，**进一寸有进一寸的欢喜**。

<!-- more -->

| 科目                    | 课程                                                                                          |
| --------------------- | ------------------------------------------------------------------------------------------- |
| [数据结构和算法](数据结构和算法.md) |                                                                                             |
| [[操作系统@]]             | [MIT 6.828 Operating System Engineering](MIT%206.828%20Operating%20System%20Engineering.md) |
| [[网络@]]               | [CS144 Computer Network](CS144%20Computer%20Network.md)                                     |
| [[数据库@]]              | [[UCB CS186 Introduction to Database System]]                                               |
| [[分布式系统]]             | [MIT 6.824 Distributed System](MIT%206.824%20Distributed%20System.md)                       |
| [机器学习](机器学习.md)       | [[2 第二大脑/1 知识/CS/CS229 Machine Learning]]                                                                                   |
| [[深度学习]]              | [[CS224n Natural Language Processing]]                                                      |

| 语言                          |
| --------------------------- |
| [C语言](C语言.md)               |
| [CPP](CPP.md)               |
| [Java@](Java@.md)           |
| [Python](Python.md)         |
| [JavaScript](JavaScript.md) |
| [Shell](Shell.md)           |

## CS 心法

任何活儿，无论是存储、网络、[ai infra](https://www.zhihu.com/search?q=ai%20infra&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D)、编译器后端、cuda，等等，都非常简单。外表高大上，看着是宾利的壳，其实核心动力是几个老鼠在壳里面蹬三轮呢。只要你干一两年基本都懂了。

你能把活儿干出花来，能快速的超越自己的限制，最重要的是计算机各个领域的基本视野和概念。

你必须知道计算机科学几乎所有的领域基本的想法是什么。比如 tcp 怎么维护 [虚拟链接](https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E9%93%BE%E6%8E%A5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D) 传递信息，如何做微观的拥塞控制；编译器怎么 [parse](https://www.zhihu.com/search?q=parse&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D) 出来 ir，如何对 ir 优化；分布式算法如何协调工作；[流式计算](https://www.zhihu.com/search?q=%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D) 里面 unbounded data 怎么做 [window/trigger](https://www.zhihu.com/search?q=window%2Ftrigger&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D)；[机器学习](机器学习.md) 里面各种模型是如何拟合数据的，为什么需要不同的拟合方式；mysql 中事务怎么做，行锁怎么设计的；[linux kernel](https://www.zhihu.com/search?q=linux%20kernel&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D) 的进程调度怎么设计、[异步 io](https://www.zhihu.com/search?q=%E5%BC%82%E6%AD%A5%20io&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D) 怎么设计……

有了这些视野之后，你要把它们从具体的领域中抽象成概念。

千万不要把自己的精力放在 "tcp 包头几个字节都是什么 "、"[c++ 17](https://www.zhihu.com/search?q=c%2B%2B%2017&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D) 引入了什么 " 这种无聊的东西上。除非你决定把你的事业投入到上面。

概念就是 [计算机科学](https://www.zhihu.com/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D) 最精华的部分，你必须学会在不同的领域复用这些概念，这样你就是有 insight(洞察力、深刻理解) 的。

比如你去写一个最简单的业务，你一定会遇到事务、parse 配置规则、[限流控制](https://www.zhihu.com/search?q=%E9%99%90%E6%B5%81%E6%8E%A7%E5%88%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A3054501672%7D)、调度，是否有一些策略可以采样训练模型自动优化……你能否把学到的概念，结合实际应用起来，这个才是工程师的意义所在。

例如，理解了图论的核心概念后，你可能会在社交网络分析、交通路线优化、甚至是生物学中的蛋白质相互作用网络中看到相似的结构和问题。这种能力就体现了 insight。

什么时候能惊艳你的概念越来越少，到最后你看绝大部分东西的时候都能说出 " 就这 "，你就是合格的工程师了。
[缓存](缓存.md)

## 暴力

1. 深度学习的"矩阵乘法大法"

深度学习听起来很高大上，像是人工智能的终极形态。其实它的核心计算无非就是矩阵乘法的反复堆叠。训练神经网络时，你基本上就是在调整一堆参数（权重），让输出越来越接近目标值，而矩阵乘法正是实现这种参数调整的关键。某种程度上，深度学习就是"大规模线性代数运算的艺术"，并没有多少"智能"可言。要不怎么GPU（图形处理器）也能拿来训练神经网络呢？因为图形处理器的设计正好是用来加速矩阵运算的。

1. TCP协议中的"重传机制"

互联网最可靠的协议之一——TCP，被誉为保障网络传输稳定性的基石。它的魔力在于确保数据可靠传输，但其实它的实现手段相当粗暴。每当数据包发送出去，对方没有在规定时间内确认收到，TCP就会直接重传这份数据！没错，它就是这么简单粗暴——靠反复尝试，直到对方确实收到为止。用"拿不到确认我就一直发"的死磕态度，硬生生保障了网络的可靠性。

1. 图像去噪中的"中值滤波"

图像处理里有种叫做"中值滤波"的技术，用来去除图像中的噪点。听名字感觉很玄乎，其实就是在图像的每个像素点附近找一圈邻居，把这些邻居的颜色值按大小排序，然后取个中间值替换掉当前像素。虽然看起来像是复杂的数学运算，但本质上不过是"把周围人的意见平均一下"的笨方法，却能大幅度提升图像的质量。

1. AI游戏玩得好靠"暴力穷举"

看过AI击败人类顶级围棋选手的新闻吗？很多AI其实是在海量的计算资源上靠"暴力穷举"找到了"完美解法"。例如蒙特卡洛树搜索，就是先模拟大量随机的下棋路径，从中统计哪些路径胜率更高。听起来是"人工智能"的成果，但更像是"体力活"——用海量的数据堆出来的成功率。AI表面上是高手，背后却是用无数机器一起"傻干"。

1. 冷启动技术——缓存预热

互联网公司总会说"优化了冷启动时间"，让应用打开速度更快。看起来很高级的样子，实质上很多时候就是靠"缓存预热"。开发者提前把用户最可能需要的数据预先加载进内存，让它随时待命。当用户真正启动应用时，数据已经在那里等着了，就给人一种"启动超快"的错觉。相当于先悄悄做了准备工作，表面上看起来像"技术升级"。

1. 黑客攻击中的"字典攻击"

很多黑客攻击听起来高深莫测，比如破解密码的技术。但最常见的"字典攻击"其实特别直接，就是准备好一堆常见的密码，像"123456"，"password"，"qwerty"等，逐个尝试登录。虽然听起来像是初级黑客才会用的方法，却依然有很多成功的案例。人们太容易用弱密码，所以这种简单"蛮力破解"往往比复杂算法还要有效。

这些技术之所以高端，是因为它们在看似简单的原理上做了极致的优化和应用，最终达到令人印象深刻的效果。可以说，这些暴力原理+智慧巧思的组合才是真正的魔法所在。

### CS lab

[北大CS自学指南 (csdiy.wiki)](https://csdiy.wiki/%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/)

#第一性原理 每一个 lab 就像一份 PRD，因为他们的本质都是用数据结构抽象某种事物，学 Lab 的过程就像做需求一样，只不过后者是理解业务，前者是理解 CS

| 主题                | 子主题                                         |     |
| ----------------- | ------------------------------------------- | --- |
| 数学进阶              | - <br>- <br>- <br>- <br>- <br>-             |     |
| 编程入门              | - <br>- <br>- <br>- <br>- <br>- <br>- <br>- |     |
| 电子基础              | - <br>- <br>-                               |     |
| 数据结构与算法           | - <br>- <br>- <br>- <br>-                   |     |
| [软件工程@](软件工程@.md) | - <br>- <br>-                               |     |
| 计算机系统基础           | - <br>-                                     |     |
| 体系结构              | - <br>- <br>- <br>-                         |     |
| 操作系统              | - <br>- <br>- <br>-                         |     |
| 并行与分布式系统          | - <br>-                                     |     |
| 计算机系统安全           | - <br>- <br>- <br>- <br>- <br>-             |     |
| 计算机网络             | - <br>- <br>-                               |     |
| 数据库系统             | - <br>- <br>- <br>- <br>-                   |     |
| 编译原理              | - <br>- <br>- <br>-                         |     |
| 编程语言设计与分析         | - <br>- <br>- <br>-                         |     |
| 计算机图形学            | - <br>- <br>- <br>- <br>- <br>-             |     |
| Web开发             | - <br>- <br>- <br>-                         |     |
| 数据科学              | -                                           |     |
| 人工智能              | - <br>-                                     |     |
| 机器学习              | - <br>- <br>-                               |     |
| 机器学习系统            | - <br>- <br>-                               |     |
| 深度学习              | - <br>- <br>- <br>- <br>- <br>- <br>-       |     |
| 机器学习进阶            | - <br>- <br>- <br>- <br>-                   |     |

计算机基础学习顺序是什么？- 编程指北的回答 - 知乎  
https://www.zhihu.com/question/473267862/answer/2009648056

如果让你重新开始学计算机，你的学习路线会怎么选择? - 知乎  
https://www.zhihu.com/question/492545174/answer/2482876550

### 思维模型

计算机思维对我个人生活和做事影响还是蛮大的，编程能力最终的体现，仍然是计算思维的运用的能力，关于计算思维有很多类，下面是我控制chatgpt，整理出一些我觉得比较重要的思维方法，其中我认为非常典型的，在我看来包括递归、迭代、并行、状态机、缓存、贪心、分层、抽象

1. 递归思维（Recursive Thinking）递归是一种解决问题的方法，特别适用于自相似结构或问题的分解。递归思维强调将问题简化为更小的同类问题，直到达到可以直接求解的基础情况。
2. 迭代思维（Iterative Thinking）通过重复执行一个步骤序列来逼近解决方案。迭代思维在循环和优化算法中应用广泛，允许逐步改进或寻找最优解。
3. 并行思维（Parallel Thinking）这是对多个问题同时处理的思考方式，强调任务分割、同步和协调。并行思维在多线程、多进程或分布式计算中非常重要。
4. 状态机思维（State Machine Thinking）用于处理有状态的系统或问题，将问题视为一系列状态转换的过程。常用于控制系统、协议设计和游戏编程等领域。
5. 缓存思维（Caching Thinking）缓存思维关注如何通过存储中间结果，避免重复计算或提高效率。在大规模系统中，缓存优化可以大大提升性能。
6. 贪心思维（Greedy Thinking）在每一步都选择当前最优解，期望最终获得全局最优解。虽然不总能找到最优解，但在某些场景下（如贪心算法），这种思维是高效的。
7. 图论思维（Graph Theory Thinking）在面对节点和边的关系时，使用图论思维可以帮助解决网络、路径规划、拓扑结构等问题。广泛用于社交网络分析、路径优化和电路设计。
8. 模糊思维（Fuzzy Thinking）计算机科学中的模糊逻辑用于处理不确定性问题，这种思维方式可以帮助在信息不完整或模糊的情况下作出合理的判断。
9. 最优化思维（Optimization Thinking）最优化思维着眼于在有限资源下找到最优或次优的解决方案。这在资源分配、路径选择等问题中非常关键。
10. 局部最优思维（Local Optimization Thinking）在面对复杂问题时，局部最优思维尝试先在局部区域找到较好的解决方案，然后逐步扩展或组合以求全局最优。这在爬山算法、局部搜索算法中尤为常见。
11. 分层思维（Layered Thinking）分层思维的本质是将复杂的系统或问题按照功能、结构或逻辑划分为不同层次，每一层只关注其具体职责并与相邻层次进行交互。这种思维方式让问题更易于管理、维护和扩展。12. 抽象思维（Abstraction Thinking）抽象思维是忽略细节，专注于事物的本质特征和核心功能的思维方式。它通过提炼出问题的核心要素，屏蔽复杂实现，使得问题更加简洁易解。


___

<zhithink>
好的，我现在需要回答用户的问题“如何培养扎实的CS基本功”，根据提供的参考内容。首先，用户之前询问过学游泳的方法，现在转向CS基本功，可能需要结构化的学习方法。参考内容提到北大信科的“CS自救指南”以及相关资源，如Github仓库和网课推荐，还有《深度学习全栈手册》。

首先，我需要提取参考内容中的关键点：推荐课程、实践项目、多语言掌握、数学基础、广泛涉猎领域、社群交流、持续学习等。然后结合这些点来组织回答。用户可能希望得到一个系统化的学习路径，包括理论、实践、资源推荐和持续学习的方法。

接下来，需要确定回答的结构。可能分为几个部分，比如课程学习、编程实践、数学基础、参与项目、社群交流等。每个部分需要具体说明怎么做，并引用参考内容中的资源，如CS自学指南的网站和相关课程，以及提到的Github仓库和社群。

同时，用户可能关心如何高效利用这些资源，避免信息过载。可能需要强调循序渐进，选择优质课程，注重项目实践，逐步掌握多门语言。另外，参考内容中提到"指南"中的课程覆盖广泛领域，需要建议用户根据兴趣选择方向，但先打好基础。

还要注意参考内容中的额外资源，如《深度学习全栈手册》和卖萌屋的社群，这些可以作为补充学习材料和交流渠道。需要将这些资源融入建议中，比如推荐加入社群交流，定期更新知识。

最后，要确保回答条理清晰，具体可行，结合理论与实践，鼓励持续学习和应用。可能需要提醒用户制定学习计划，平衡广度与深度，参与实际项目等。
</zhithink>

要系统培养扎实的CS基本功，可参考北大信科内部流传的"CS自救指南"方法论，结合结构化学习路径：

**一、课程体系化学习（核心骨架）**
1. **精选网课与教材**  
   - 优先选择国际顶尖课程（如MIT 6.001、CMU 15-213），参考[CS自学指南](https://csdiy.wiki/)中的课程分级与配套资源  
   - 每门课完成：视频学习+教材精读+配套作业（如CS61A的Python编程项目）
   - 重点领域必修：
     - 计算机系统：《深入理解计算机系统》+ Lab实战  
     - 算法：《算法导论》+ LeetCode分类训练  
     - 操作系统：MIT 6.S081配合xv6实验  

2. **编程语言能力矩阵**  

   | 层级   | 目标语言           | 应用场景          |
   | ------ | ------------------ | ----------------- |
   | 基础层 | C/Python           | 系统开发/算法原型 |
   | 进阶层 | Java/Go/JavaScript | 后端/分布式/全栈  |
   | 工具层 | SQL/Shell          | 数据操作/自动化   |
   |        |                    |                   |
   |        |                    |                   |  

   要求每学期掌握1门新语言，累计完成10+个千行代码项目（如用C实现简易数据库，用Go开发Web服务）

**二、数学与理论筑基（地基工程）**  
4. **离散数学与概率统计**  
   - 完成MIT 6.042J证明训练，掌握归纳法、图论、组合数学  
   - 结合《概率编程实践》完成贝叶斯网络编程项目  
1. **数值分析与线性代数**  
   - 通过Coding the Matrix课程实现矩阵运算库  
   - 使用NumPy完成PCA降维实战

**三、工程能力淬炼（实战熔炉）**  
6. **项目进阶路线**  
   - 初级：CLI工具开发（如Linux Shell复刻）
   - 中级：RPC框架实现/迷你操作系统  
   - 高级：分布式键值存储/简易深度学习框架  
   参考指南中Github仓库的50+项目模板（含代码实现与文档）
1. **工具链打磨**  
   - 开发环境：VSCode/Vim+Git+Linux终端定制  
   - 调试技能：GDB实战核心转储分析，性能剖析工具(perf, pprof)  
   - 协同开发：参与3人以上开源项目（如给Apache项目提交PR）

**四、领域纵深拓展（战略选择）**  
8. **人工智能方向**  
   - 理论：《深度学习全栈手册》+ 实现经典论文代码（如Transformer）
   - 实战：Kaggle竞赛（至少1银牌）或顶会复现项目  
1. **系统方向**  
   - 完成CMU 15-721数据库系统实现  
   - 参与CNCF沙箱项目贡献（如TiKV/RISC-V生态）

**五、持续演进机制**  
10. 加入[卖萌屋技术社群](入群方式见参考内容)参与周更论文解读  
11. 建立个人知识库：用GitBook维护学习笔记，每月产出1篇技术博客  
12. 参与开源之夏/Google Summer of Code，获得工业级代码经验

**关键数据指标**  
- 代码量：累计10万行+（含测试与文档）
- 理论基础：完成20+证明类作业（如分布式系统共识算法推导）
- 工具掌握：熟练使用15+开发工具链（从LLVM到Kubernetes）
- 领域证书：获取至少1个顶级认证（如AWS解决方案架构师）

通过该体系训练约2-3年（每周投入20小时），可达到：  
13. 能在48小时内实现大多数论文核心算法  
14. 具备从零设计中型系统架构的能力  
15. 对新技术栈的掌握速度比同行快3倍以上

建议配合《CS自学指南》中的"生存模式"时间表（每日4小时高效学习+2小时实践），定期通过指南中的自测题检验知识漏洞。
