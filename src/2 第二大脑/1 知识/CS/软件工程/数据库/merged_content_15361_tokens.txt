Directory Tree:
==============

└── 数据库
    ├── Canal.md
    ├── MySQL.md
    ├── Mybatis
    │   └── Mybatis.md
    ├── ORM.md
    ├── PostgreSQL.md
    ├── SQL.md
    ├── schema.md
    ├── 三范式.md
    ├── 分库分表.md
    ├── 向量数据库.md
    ├── 数据
    │   ├── ClickHouse.md
    │   ├── NoSQL.md
    │   ├── Redis@.md
    │   ├── 字符，字节，位数，KB，MB.md
    │   ├── 时序数据库.md
    │   └── 行式存储和列式存储.md
    ├── 数据库@.md
    ├── 数据库最佳实践
    │   ├── 1 建表 5-10.md
    │   ├── 2 加索引 4.md
    │   ├── 3 写SQL  9.md
    │   ├── ClickHouse.md
    │   ├── PG 数据导出迁移.md
    │   └── 为什么要用数据库？.md
    └── 非结构化数据.md

File Contents:
==============


[Canal.md]
==========

---
draw:
tags: []
title: Canal
date created: 2024-10-13
date modified: 2024-11-12
---

Canal是阿里巴巴开源的一个数据库同步工具,主要用于MySQL数据库的增量数据同步。它的主要特点和用途包括:  1. 数据同步: Canal可以实时捕获MySQL数据库的变更(增删改),并将这些变更同步到其他系统,如其他数据库、消息队列等。  2. 数据库复制: 可用于构建MySQL主从复制架构,实现数据备份和读写分离。  3. 数据分析: 通过捕获数据变更,可以将数据实时传输到大数据分析平台,用于实时数据分析。  4. 缓存更新: 可以用来实时更新缓存,保持缓存与数据库的一致性。  5. 技术原理: Canal模拟MySQL slave的交互协议,伪装自己为MySQL slave,向MySQL master发送dump协议,从而获取binary log内容。  6. 高可用性: 支持HA模式,确保服务的可靠性。  Canal广泛应用于数据同步、实时分析、缓存更新等场景,是构建分布式系统和数据流处理的重要工具。  如果您想了解更多具体细节,比如Canal的工作原理、配置方法或使用案例,我可以进一步为您解释。​​​​​​​​​​​​​​​​



[MySQL.md]
==========

---
draw:
tags: []
title: MySQL
date created: 2024-07-31
date modified: 2024-12-27
---

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fpicgo%2Fpicgo-clipboard-images%2F2024%2F10%2F03%2F19-36-10-1028673df0cbd44890ba678e109badd7-202410031936659-73b8fd.png)

| 模块   | 讲次   | 标题                           | 时长    |     |
| ---- | ---- | ---------------------------- | ----- | --- |
| 开篇词  | 开篇词  | 这一次，让我们一起来搞懂MySQL            | 06:04 |     |
| 基础篇  | 01   | 基础架构：一条SQL查询语句是如何执行的？| 12:51 |     |
|      | 02   | 日志系统：一条SQL更新语句是如何执行的？| 15:07 |     |
|      | 03   | 事务隔离：为什么你改了我还看不见？| 11:02 |     |
|      | 04   | 深入浅出索引（上）| 15:29 |     |
|      | 05   | 深入浅出索引（下）| 09:52 |     |
|      | 06   | 全局锁和表锁：给表加个字段怎么有这么多阻碍？| 13:02 |     |
|      | 07   | 行锁功过：怎么减少行锁对性能的影响？| 11:32 |     |
|      | 08   | 事务到底是隔离的还是不隔离的？| 19:05 |     |
| 实践篇  | 09   | 普通索引和唯一索引，应该怎么选择？| 15:40 |     |
|      | 10   | MySQL为什么有时候会选错索引？| 17:29 |     |
|      | 11   | 怎么给字符串字段加索引？| 12:48 |     |
|      | 12   | 为什么我的MySQL会"抖"一下？| 15:37 |     |
|      | 13   | 为什么表数据删掉一半，表文件大小不变？| 14:37 |     |
|      | 14   | count(*)这么慢，我该怎么办？| 15:23 |     |
|      | 15   | 答疑文章（一）：日志和索引相关问题            | 20:20 |     |
|      | 16   | "order by"是怎么工作的？| 17:01 |     |
|      | 17   | 如何正确地显示随机消息？| 16:28 |     |
|      | 18   | 为什么这些SQL语句逻辑相同，性能却差异巨大？| 15:36 |     |
|      | 19   | 为什么我只查一行的语句，也执行这么慢？| 12:21 |     |
|      | 20   | 幻读是什么，幻读有什么问题？| 19:27 |     |
|      | 21   | 为什么我只改一行的语句，锁这么多？| 17:38 |     |
|      | 22   | MySQL有哪些"饮鸩止渴"提高性能的方法？| 14:47 |     |
|      | 23   | MySQL是怎么保证数据不丢的？| 17:04 |     |
|      | 24   | MySQL是怎么保证主备一致的？| 19:52 |     |
|      | 25   | MySQL是怎么保证高可用的？| 17:23 |     |
|      | 26   | 备库为什么会延迟好几个小时？| 23:17 |     |
|      | 27   | 主库出问题了，从库怎么办？| 19:55 |     |
|      | 28   | 读写分离有哪些坑？| 21:22 |     |
|      | 29   | 如何判断一个数据库是不是出问题了？| 14:31 |     |
|      | 30   | 答疑文章（二）：用动态的观点看加锁            | 15:43 |     |
|      | 31   | 误删数据后除了跑路，还能怎么办？| 15:31 |     |
|      | 32   | 为什么还有kill不掉的语句？| 13:38 |     |
|      | 33   | 我查这么多数据，会不会把数据库内存打爆？| 14:33 |     |
|      | 34   | 到底可不可以使用join？| 16:42 |     |
|      | 35   | join语句怎么优化？| 16:39 |     |
|      | 36   | 为什么临时表可以重名？| 16:07 |     |
|      | 37   | 什么时候会使用内部临时表？| 13:54 |     |
|      | 38   | 都说InnoDB好，那还要不要使用Memory引擎？| 14:00 |     |
|      | 39   | 自增主键为什么不是连续的？| 17:34 |     |
|      | 40   | insert语句的锁为什么这么多？| 12:18 |     |
|      | 41   | 怎么最快地复制一张表？| 13:30 |     |
|      | 42   | grant之后要跟着flush privileges吗？| 12:54 |     |
|      | 43   | 要不要使用分区表？| 12:51 |     |
|      | 44   | 答疑文章（三）：说一说这些好问题             | 16:21 |     |
|      | 45   | 自增id用完怎么办？| 17:07 |     |
| 特别放送 | 直播回顾 | 林晓斌：我的 MySQL 心路历程            | 18:43 |     |
| 结束语  | 结束语  | 点线网面，一起构建MySQL知识网络           | 08:01 |     |
| 结课测试 | 结课测试 | 这些MySQL知识你都掌握了吗？| 00:28 |     |
|      |      |                              |       |     |
|      |      |                              |       |     |

```Java
[2024-07-31 15:08:40][QTraceId[h_grocery_240730.160200.10.71.162.188.247.2_0]-QSpanId[1]][db-guardian-check-thread-1][com.qunar.db.guardian.RunningSqlHolds][WARN ] db_guardian sql time too long,will cancel ds:pxc_hotel_common_w,sql=select
                trace_id,
                user_id,user_request_code,validation_time,booking_reason,
                from_date,to_date,hotel_seq,room_id,wrapper_id,city_url,submit,
                detail_reason,validation_result_type,wrapper_product,query,order_product,final_result,fields_detail,change_reasons,business_type
                from validation_detail
                 WHERE  validation_time >= ?


                                and validation_time <= ?
                order by validation_time desc limit ?,md5=d54dbee37ee6726eb664e7e16ed7ede3,qtrace=h_grocery_240731.150759.10.71.146.129.225.16122_1,time=40866
```

性能问题：这些日志显示 SQL 查询执行时间过长（超过 20 秒和 35 秒），导致数据库守护进程准备取消这些查询。

## 网络协议

就像浏览器之间用基于[TCP](TCP.md)的[HTTP 1.1](HTTP%201.1.md)通信一样，想和 Mysql 数据库通信，需要通过一种**MySQL 协议**，以下是关于 MySQL 协议的一些重要信息：

1. 基础协议：
   - MySQL 协议是基于 TCP/IP 的。
   - 默认情况下，MySQL 服务器监听 TCP 端口 3306。
2. 协议特性：
   - 它是一个二进制协议，不像 HTTP 那样是文本协议。
   - 支持全双工通信，允许客户端和服务器同时发送数据。
3. 协议结构：
   MySQL 协议的通信包括几个主要部分：
   - 握手阶段（身份验证）
   - 命令阶段（查询执行）
   - 结果集传输
4. 安全性：
   - 支持 SSL/TLS 加密，可以在 TCP 层之上添加加密层。
   - 包含各种身份验证方法，如密码认证、证书认证等。
5. 版本差异：
   - 不同版本的 MySQL 可能在协议细节上有所不同。
   - MySQL 8.0 引入了一些新的协议特性，如 caching_sha2_password 认证。

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: TCP Connection
    Server->>Client: Handshake Packet
    Client->>Server: Authentication Response
    Server->>Client: OK or Error Packet

    loop Command Phase
        Client->>Server: Command Packet (e.g., Query)
        Server->>Client: Result Set or OK/Error Packet
    end

    Client->>Server: Quit Command
    Server->>Client: OK Packet
    Note over Client,Server: TCP Connection Closed

```

这个流程图展示了 MySQL 客户端和服务器之间的基本通信过程。

比较 MySQL 协议和 HTTP：

1. 用途：
   - HTTP 主要用于 Web 通信。
   - MySQL 协议专门用于数据库操作。

2. 结构：
   - HTTP 是无状态的，每个请求都是独立的。
   - MySQL 协议是有状态的，维护一个持续的会话。

3. 数据格式：
   - HTTP 主要使用文本格式（虽然可以传输二进制数据）。
   - MySQL 协议使用二进制格式，效率更高。

4. 连接管理：
   - HTTP 通常是短连接（尽管 HTTP/1.1 引入了持久连接）。
   - MySQL 通常保持长连接，以减少连接建立的开销。

5. 复杂性：
   - HTTP 相对简单，易于调试。
   - MySQL 协议更复杂，专门针对数据库操作进行了优化。

在实际应用中，开发者通常不需要直接处理 MySQL 协议的细节。数据库驱动程序（如 Python 的 mysql-connector 或 mysqlclient）会处理这些底层通信细节。

但是，了解这些协议的工作原理对于优化数据库性能、排查连接问题和理解网络安全性都很有帮助。您对 MySQL 协议的某个特定方面感兴趣，或者想了解更多关于如何在应用中高效使用 MySQL 连接的信息吗？



[Mybatis/Mybatis.md]
====================

---
draw:
tags: []
title: Mybatis
date created: 2024-01-15
date modified: 2024-12-27
---

## MyBatis 领域词汇表

| 术语           | 含义                                                         |
|---------------|-------------------------------------------------------------|
| 映射器文件     | 定义 SQL 语句和 Java 对象之间映射关系的 XML 文件                |
| SqlSession    | MyBatis 的核心接口，用于执行 SQL 命令、获取映射器和管理事务      |
| 会话工厂       | 用于生成 SqlSession 的工厂类                                   |
| 数据源         | 数据库连接的来源，配置 JDBC 数据库连接信息                     |
| 连接池         | 数据库连接的缓存池，提高数据库连接效率                         |
| 事务管理       | 控制事务提交、回滚和关闭的管理接口                             |
| 动态 SQL       | 根据条件动态生成 SQL 语句                                      |
| 映射接口       | 映射器文件对应的 Java 接口，用于定义 SQL 操作方法              |
| 输入映射       | 将 Java 对象映射为 SQL 语句的输入参数                          |
| 输出映射       | 将 SQL 查询结果映射回 Java 对象                                |
| 参数占位符     | 在 SQL 语句中用于代替实际参数值的占位符                        |
| 结果集处理     | 处理从数据库查询返回的结果集                                   |
| 选择器         | 特定的 SQL 语句，用于从数据库中选择数据                        |
| 插入器         | 特定的 SQL 语句，用于将数据插入数据库                          |
| 更新器         | 特定的 SQL 语句，用于更新数据库中的数据                        |
| 删除器         | 特定的 SQL 语句，用于从数据库中删除数据                        |
| 绑定方法       | 将方法调用绑定到指定的 SQL 操作                                |
| 类型别名       | 为 Java 类型设置一个简短的名字，简化配置文件中的类型引用        |
| 类型处理器     | 处理 Java 类型与数据库类型之间的转换                           |
| 拦截器         | 可插拔的组件，用于拦截核心执行的操作（如 SQL 执行）|
| 插件           | 自定义修改 MyBatis 核心行为的方法，通常用于扩展功能            |
| 缓存           | 存储已执行 SQL 的结果，以提高查询效率                          |
| 本地缓存       | SqlSession 级别的缓存，用于缓存一个会话中的数据                |
| 二级缓存       | 映射器级别的缓存，跨多个 SqlSession 共享                       |
| 延迟加载       | 延迟初始化对象属性，直到真正使用时才查询数据库                 |
| SQL 构建器     | 程序化方式构建 SQL 语句的工具                                 |
| XML 构建器     | 解析映射器 XML 文件的工具                                      |
| 注解           | 用于在接口方法上定义 SQL，替代 XML 映射文件的方式              |
| 会话绑定       | 将 SqlSession 绑定到特定的 Java 对象或生命周期中                |
| 会话跟踪       | 跟踪和管理 SqlSession 的状态和事务行为                         |
| 事务隔离级别   | 定义数据库操作的事务隔离级别                                  |
| 事务传播行为   | 定义事务方法调用的行为模式                                    |
| 配置解析       | 解析 MyBatis 配置文件并构建运行环境                            |
| 字段映射       | 将数据库表的字段映射到 Java 对象的属性中                       |
| 集合映射       | 处理 SQL 查询结果为集合类型的映射                              |
| 级联映射       | 映射涉及到对象关联的复杂 SQL 结构                             |
| 分步查询       | 将复杂的查询拆分为多个步骤执行，通常用于优化性能               |
| 标识生成       | 自动生成主键值的策略                                          |
| SQL 片段       | 重用 SQL 代码的片段，通过 `<include>` 标签包含在其他 SQL 中    |
| 查询缓存       | 用于缓存查询结果，减少数据库访问次数                          |
| 条件构造       | 动态构建 SQL 中的条件表达式                                   |
| 语句构造器     | 构建动态 SQL 语句的组件                                       |
| 执行器         | 负责执行 SQL 命令并返回处理结果的组件                          |
| 环境配置       | 定义 MyBatis 运行环境的设置，如数据源和事务管理的配置          |
| 日志配置       | 配置 MyBatis 日志行为，用于调试和监控                          |
| 映射注册       | 在配置中注册和管理 SQL 映射的过程                              |
| 实体类         | 代表数据库表中数据的 Java 类                                  |
| 分页查询       | 对查询结果进行分页处理的技术                                  |
| 优化查询       | 提高查询效率的策略，例如使用合适的索引                        |
| 查询参数       | 传递给 SQL 语句的参数                                        |
| 返回值处理     | 处理 SQL 查询或命令的返回结果                                 |
| SQL 审计       | 跟踪和记录执行的 SQL 语句，用于性能分析和安全监控              |
| 会话超时       | 设置 SqlSession 的超时时间，影响事务的持续时间                |
| 配置验证       | 启动时检查 MyBatis 配置的正确性                               |
| 数据完整性     | 确保数据库操作不破坏数据的准确性和一致性                      |
| 错误处理       | 管理和响应 SQL 执行过程中发生的错误                           |
| 性能监控       | 跟踪 SQL 执行时间和资源使用，用于优化                          |
| 安全控制       | 防止 SQL 注入等安全威胁的策略                                 |
| 代码生成       | 自动生成基于 MyBatis 的数据访问层代码                         |
| 批处理         | 同时执行多条 SQL 语句以提高性能                               |
| 事务日志       | 记录事务操作的详细信息，用于故障恢复                          |
| 数据迁移       | 将数据从一个数据库迁移到另一个数据库的过程                    |
| 数据校验       | 在执行 SQL 之前验证数据的合法性                               |
| 语句重用       | 在多个查询中重用相同的 SQL 语句                               |
| 资源管理       | 管理数据库连接、语句和结果集的资源                            |
| 数据映射       | 将数据库中的数据转换为应用程序中的数据结构                    |
| 应用集成       | 将 MyBatis 集成到企业应用架构中                              |
| 依赖注入       | 自动将依赖关系注入到组件中，简化配置和管理                    |
| 模块化设计     | 将系统分解为多个模块，各自独  

画一个 java-spring-mybatis-jdbc-pg 的图

The _where_ element knows to only insert "WHERE" if there is any content returned by the containing tags. Furthermore, if that content begins with "AND" or "OR", it knows to strip it off.  
If the _where_ element does not behave exactly as you like, you can customize it by defining your own trim element. For example, the trim equivalent to the _where_ element is:



[ORM.md]
========

---
draw:
tags: []
title: ORM
date created: 2024-10-17
date modified: 2024-12-27
---

## 是啥？

ORM 是 "Object-Relational Mapping"（对象关系映射）的缩写。在数据库上下文中，ORM 是一种编程技术，用于将面向对象编程语言中的对象与关系型数据库中的表进行映射。

主要特点和优势：

1. 将数据库表映射到编程语言中的类。
2. 将表中的行映射到类的实例（对象）。
3. 将表中的列映射到对象的属性。
4. 提供了一种以面向对象方式操作数据库的方法。
5. 减少了直接编写 SQL 查询的需要，提高了开发效率。
6. 增强了代码的可维护性和可读性。
7. 提供了数据库无关性，使得切换不同的数据库系统变得更容易。

常见的 ORM 框架包括：

- Python: SQLAlchemy, Django ORM
- Java: Hibernate, JPA
- Ruby: Active Record (Rails)
- PHP: Doctrine, Eloquent (Laravel)
- .NET: Entity Framework

使用 ORM 可以让开发者更专注于业务逻辑，而不是底层的数据库操作细节。但是，在某些复杂查询或高性能要求的场景下，可能还是需要直接使用 SQL 来获得更好的控制和性能。

## 原理是什么？

```mermaid
graph TD
    A[对象模型] -->|映射| B[关系模型]
    B -->|映射| A
    C[类] -->|映射| D[表]
    E[对象] -->|映射| F[行]
    G[属性] -->|映射| H[列]
    I[方法] -->|转换| J[SQL语句]
```



[PostgreSQL.md]
===============

---
draw:
tags: []
title: PostgreSQL
date created: 2024-09-15
date modified: 2025-01-07
---

```Java

postgres=# \du
                                   List of roles
 Role name |                         Attributes                         | Member of 
-----------+------------------------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 root      |                                                            | {}
```

```Java
postgresql://<用户名>:<密码>@<主机名>:<端口>/<数据库名>

postgresql://root   :root @localhost     /root

docker run -e POSTGRES_USER=<用户名> -e POSTGRES_PASSWORD=<密码> -e POSTGRES_DB=<数据库名> <镜像名>

docker run -e POSTGRES_USER=root -e POSTGRES_PASSWORD=root -e POSTGRES_DB=root postgres
```

`docker run -d -p 5432:5432 --name postgres -e POSTGRES_PASSWORD=postgres postgres:latest`  
![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fpicgo%2Fpicgo-clipboard-images%2F2024%2F12%2F23%2F15-11-21-e7e4f32e293b763d1b3dc73acd22b215-202412231511540-b64210.png)

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fpicgo%2Fpicgo-clipboard-images%2F2024%2F12%2F11%2F22-41-58-36c45981869b5cefd5196851aa51fc47-202412112241647-f2b204.png)

## 数据结构

### JSSONB

使用 `JSONB` 类型的优势包括：

1. 灵活性：可以存储任意数量的例句，而不需要预先定义固定的列数。
2. 查询效率：PostgreSQL 提供了多种 JSON 操作符和函数，可以高效地查询和操作 JSON 数据。
3. 索引支持：可以在 JSONB 列上创建索引，提高查询性能。
	- [ ] 需要在数据库中为 `active_use_scenario` 列创建一个 GIN (Generalized Inverted Index) 索引。
4. 数据完整性：PostgreSQL 会验证插入的 JSON 数据的有效性。

```Java

```



[SQL.md]
========

---
draw:
tags: []
title: SQL
date created: 2024-10-03
date modified: 2024-12-27
---

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fpicgo%2Fpicgo-clipboard-images%2F2024%2F10%2F03%2F19-40-07-52b881783ca0b97348eed37fa772b69e-202410031940711-70c86a.png)

## limit

在SQL中,它是这样用的:

`SELECT * FROM 表名 LIMIT 5;`

这条语句的意思是:"从这个表里给我拿5条数据"。

如果你想跳过前面的一些数据,可以这样写:

`SELECT * FROM 表名 LIMIT 10, 5;`

这就像是说:"先跳过10颗糖果,然后给我5颗"。

```Java
{
  "cycleMarking": "300",
  "msyType": "normal",
  "groupNo": 2,
  "isEmergency": false,
  "dataInfo": {
    "hotel": {
      "hotel_commission_rate": 500,
      "hotel_special_rate": 100
    },
    "physical": {
      "room_type_commission_rate": 1000,
      "room_type_special_rate": 200
    },
    "homogenized": {
      "homogenized_room_rate": 800,
      "homogenized_special_rate": 150
    }
  }
}

```

```Java
/Users/liuyishou/work/hotel-data-center/provider/src/main/webapp/dynamicConfig/cleanUpNotFreshData.jsp



/Users/liuyishou/work/hotel-data-center/provider/src/main/webapp/realTimeRate/bucketRateTest.jsp
```



[schema.md]
===========

---
draw:
tags: []
title: schema
date created: 2024-10-11
date modified: 2024-12-27
---

可以给不同的人不同的权限，就像你可以决定谁能碰你的乐高。有利于鉴权

<!-- more -->

好的，让我用简单的话来解释一下数据库中的 schema 是什么意思。

想象一下你有一个很大的玩具箱，这就像是一个数据库。现在，schema 就像是你在这个玩具箱里整理玩具的方式。

1. 定义：
   schema 是数据库的一种组织方式，它帮助我们把相关的表格和其他数据库对象放在一起。

2. 比喻：
   如果数据库是一个大书柜，schema 就像是书柜里的不同书架。每个书架可以放不同类型的书。

3. 作用：
   - 帮助整理：就像你把乐高玩具和芭比娃娃分开放一样。
   - 避免混乱：防止不同项目的表格名字撞车，就像避免你的玩具和妹妹的玩具混在一起。

4. 实际例子：
   假设你在做一个学校的项目：
   - 你可以有一个叫 " 学生 " 的 schema，里面放学生相关的表格。
   - 另一个叫 " 老师 " 的 schema，放老师相关的表格。

5. 在代码中：
   当你用 Java 连接数据库时，你可能会看到类似这样的代码：

   ```java
   String url = "jdbc:mysql://localhost:3306/school_db";
   ```

   这里的 "school_db" 就可能是一个 schema 名。

6. 好处：
   - 让大项目更容易管理，就像把你的玩具分类放好，想找什么都很快。
   - 可以给不同的人不同的权限，就像你可以决定谁能碰你的乐高。

记住，不是所有数据库系统都用 "schema" 这个词，有些可能叫它 " 数据库 " 或其他名字，但概念是相似的。

希望这个解释对你有帮助！如果还有不明白的地方，随时问我哦。



[三范式.md]
========

---
draw:
tags: []
title: 三范式
date created: 2024-07-14
date modified: 2024-11-12
---

数据库第一二三范式到底在说什么？- 刘慰的文章 - 知乎  
https://zhuanlan.zhihu.com/p/20028672



[分库分表.md]
=========

---
draw:
tags: []
title: 分库分表
date created: 2024-07-14
date modified: 2024-12-27
---

分表是增加单位数据所享有的CRUD 资源，分库是增加单位数据所享有的数据库基建。分表解决的是大数据量的问题，分库解决的是高并发的问题。

分库分表就像把一个大超市拆分成多个小超市：

分库：把一个大数据库拆成多个独立的小数据库

- 比如按用户ID分，北京用户的数据放A库，上海用户放B库

分表：把一张大表拆成多张小表

- 比如把订单表按年份分，2023年订单放orders_2023表，2024年放orders_2024表

主要目的：

- 解决数据量太大导致查询慢
- 避免单个数据库压力太大

就像大超市顾客太多会拥堵，分成小超市后，每家店顾客都变少了，服务也更快了。

在面试时被问到，为什么 MySQL 数据库数据量大了要进行分库分表？- Coder 的技术之路的回答 - 知乎  
https://www.zhihu.com/question/459955079/answer/1904557377

在让你设计分库分表的时候，一定要知道，**分库、分表、分库分表他是三件事**儿，不是一件事儿。所以首先你要说的就是我们需要考虑是否需要分库、是否需要分表。

如果说做这个方案的目的是为了解决单表数据量太大，查询效率慢的问题，那分表就够了，把这些数据分散到不同的表中，让每一张单表的数据量变小，那就可以了。

如果说，做这个方案的目的，是为了解决并发量太高，数据库连接数不够、数据库的资源性能（内存、CPU、磁盘）不够的问题，那就需要做分库，用更多的数据库实例来抗更高的并发。

所以说，**分表解决的是大数据量的问题，分库解决的是高并发的问题**。但一般来说，高并发往往伴随着大数据量，所以很多时候分库分表是一起做的。但是也不绝对。有些系统就是并发不高，但是年头很多了，数据量很大。



[向量数据库.md]
==========

---
draw:
tags: []
title: 向量数据库
date created: 2024-07-14
date modified: 2024-11-12
---

为什么各大 VC 最近都在投向量数据库？- 几点 James 的回答 - 知乎  
https://www.zhihu.com/question/603117242/answer/3054892818



[数据/ClickHouse.md]
==================

---
draw:
title: ClickHouse
tags: [信息革命, 数据]
date created: 2024-04-07
date modified: 2024-11-12
---

ClickHouse

<!-- more -->

ClickHouse 到底有多神？- armsword 的回答 - 知乎  
[https://www.zhihu.com/question/505958148/answer/3419819090](https://www.zhihu.com/question/505958148/answer/3419819090)



[数据/NoSQL.md]
=============

---
draw:
title: NoSQL
tags: [信息革命, 数据]
date created: 2024-04-25
date modified: 2024-11-12
---

excerpt

<!-- more -->

  

NoSQL（意为 " 非 SQL" 或 " 非关系型 "）数据库是一种数据库设计，用来存储、检索和管理数据，它与传统的关系型数据库管理系统（RDBMS）不同。NoSQL 数据库的主要特点包括：

1. **灵活的数据模型**：NoSQL 数据库通常允许更灵活的数据模型。它们可以存储半结构化数据或非结构化数据，并且不需要严格定义的表结构。
    
2. **可扩展性**：NoSQL 数据库通常设计用于分布式计算环境，易于扩展到多台服务器上，以处理大量数据。
    
3. **高性能**：对于特定类型的查询和大数据操作，NoSQL 数据库可以提供比关系型数据库更高的性能。
    
4. **多样的数据库类型**：NoSQL 是一个广泛的术语，包括多种数据库类型，如文档数据库（MongoDB、CouchDB）、键值对数据库（Redis、DynamoDB）、宽列存储（Cassandra、HBase）和图形数据库（Neo4j、OrientDB）。
    

这个名称 " 非 SQL" 或 "NoSQL" 起初是为了描述那些不使用 SQL 作为主要查询语言的数据库。随着时间的推移，NoSQL 更多地被看作是非关系型数据库的简称，强调它们与传统 SQL 数据库在设计和应用上的区别。



[数据/Redis@.md]
==============

---
draw:
tags: []
title: Redis@
date created: 2024-06-29
date modified: 2024-11-12
---

| 模块 | 讲次 | 标题 | 时长 |
|------|------|------|------|
| 开篇词 | 开篇词 | 这样学Redis，才能技高一筹 | 12:58 |
| 基础篇 | 01 | 基本架构：一个键值数据库包含什么？| 18:50 |
| | 02 | 数据结构：快速的Redis有哪些慢操作？| 19:07 |
| | 03 | 高性能IO模型：为什么单线程Redis能那么快？| 13:23 |
| | 04 | AOF日志：宕机了，Redis如何避免数据丢失？| 14:40 |
| | 05 | 内存快照：宕机后，Redis如何实现快速恢复？| 14:59 |
| | 06 | 数据同步：主从库如何实现数据一致？| 16:25 |
| | 07 | 哨兵机制：主库挂了，如何不间断服务？| 15:23 |
| | 08 | 哨兵集群：哨兵挂了，主从库还能切换吗？| 14:30 |
| | 09 | 切片集群：数据增多了，是该加内存还是加实例？| 16:58 |
| | 10 | 第1～9讲课后思考题答案及常见问题答疑 | 21:13 |
| 实践篇 | 11 | "万金油"的String，为什么不好用了？| 16:21 |
| | 12 | 有一亿个keys要统计，应该用哪种集合？| 20:12 |
| | 13 | GEO是什么？还可以定义新的数据类型吗？| 20:15 |
| | 14 | 如何在Redis中保存时间序列数据？| 17:07 |
| | 15 | 消息队列的考验：Redis有哪些解决方案？| 21:03 |
| | 16 | 异步机制：如何避免单线程模型的阻塞？| 14:55 |
| | 17 | 为什么CPU结构也会影响Redis的性能？| 24:22 |
| | 18 | 波动的响应延迟：如何应对变慢的Redis？（上）| 15:15 |
| | 19 | 波动的响应延迟：如何应对变慢的Redis？（下）| 16:49 |
| | 20 | 删除数据后，为什么内存占用率还是很高？| 15:48 |
| | 21 | 缓冲区：一个可能引发"惨案"的地方 | 20:30 |
| | 22 | 第11～21讲课后思考题答案及常见问题答疑 | 21:48 |
| | 23 | 旁路缓存：Redis是如何工作的？| 15:58 |
| | 24 | 替换策略：缓存满了怎么办？| 19:27 |
| | 25 | 缓存异常（上）：如何解决缓存和数据库的数据不一致问题？| 13:34 |
| | 26 | 缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？| 14:57 |
| | 27 | 缓存被污染了，该怎么办？| 18:09 |
| | 28 | Pika：如何基于SSD实现大容量Redis？| 19:42 |
| | 29 | 无锁的原子操作：Redis如何应对并发访问？| 12:49 |
| | 30 | 如何使用Redis实现分布式锁？| 18:19 |
| | 31 | 事务机制：Redis能实现ACID属性吗？| 15:28 |
| | 32 | Redis主从同步与故障切换，有哪些坑？| 14:23 |
| | 33 | 脑裂：一次奇怪的数据丢失 | 11:48 |
| | 34 | 第23~33讲课后思考题答案及常见问题答疑 | 15:11 |
| | 35 | Codis VS Redis Cluster：我该选择哪一个集群方案？| 20:24 |
| | 36 | Redis支撑秒杀场景的关键技术和实践都有哪些？| 13:32 |
| | 37 | 数据分布优化：如何应对数据倾斜？| 13:27 |
| | 38 | 通信开销：限制Redis Cluster规模的关键因素 | 12:25 |
| 期中测试 | 期中测试题 | 一套习题，测出你的掌握程度 | 05:29 |
| | 期中测试题答案 | 这些问题，你都答对了吗？| 06:34 |
| 未来篇 | 39 | Redis 6.0的新特性：多线程、客户端缓存与安全 | 14:55 |
| | 40 | Redis的下一步：基于NVM内存的实践 | 12:00 |
| | 41 | 第35～40讲课后思考题答案及常见问题答疑 | 12:02 |
| 加餐篇 | 加餐（一）| 经典的Redis学习资料有哪些？| 09:24 |
| | 加餐（二）| 用户Kaito：我是如何学习Redis的？| 15:11 |
| | 加餐（三）| 用户Kaito：我希望成为在压力中成长的人 | 11:22 |
| | 加餐（四）| Redis客户端如何与服务器端交换命令和数据？| 14:54 |
| | 加餐（五）| Redis有哪些好用的运维工具？| 11:21 |
| | 加餐（六）| Redis的使用规范小建议 | 15:10 |
| | 加餐（七）| 从微博的Redis实践中，我们可以学到哪些经验？| 13:41 |
| 结束语 | 期末测试 | 这些Redis核心知识，你都掌握了吗？| 00:15 |
| | 结束语 | 从学习Redis到向Redis学习 | 08:57 |

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fpicgo%2Fpicgo-clipboard-images%2F2024%2F09%2F01%2F20-02-57-9202e4f53f4439dfe3d2b597d5a8a46a-202409012002600-5a66e1.png)

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fpicgo%2Fpicgo-clipboard-images%2F2024%2F06%2F29%2F17-47-26-a18d65ee4d5d924e25b895c27089de62-20240629174725-9cac99.png)

彻底理解 [IO多路复用](IO多路复用.md) - 木川 AI 编程的文章 - 知乎  
https://zhuanlan.zhihu.com/p/150972878



[数据/字符，字节，位数，KB，MB.md]
======================

---
draw:
title: 字符，字节，位数，KB，MB
tags: [信息革命, 数据]
date created: 2024-04-28
date modified: 2024-12-27
---

![IST_1183_99214.png|400](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Ftmp%2F%E5%8D%83%E5%9B%BE_%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%9C%A8%E7%BA%BF%E6%90%9C%E7%B4%A2%E4%BB%A3%E7%A0%81%E6%94%BE%E5%A4%A7%E9%95%9C_%E5%9B%BE%E7%89%87%E7%BC%96%E5%8F%B769890404%2F2024%2F05%2F02%2F15-28-24-4d32c6186a8465f253c9ff0fd51e9105-IST_1183_99214-7bf59a.png)

在 Java 中十万个长度为 "beijing_123132" 的字符串是多少 M？

<!-- more -->
- [三个长度单元](#%E4%B8%89%E4%B8%AA%E9%95%BF%E5%BA%A6%E5%8D%95%E5%85%83)
	- [字符 character 维度](#%E5%AD%97%E7%AC%A6%20character%20%E7%BB%B4%E5%BA%A6)
	- [字节 Byte 维度](#%E5%AD%97%E8%8A%82%20Byte%20%E7%BB%B4%E5%BA%A6)
	- [KB，MB](#KB%EF%BC%8CMB)
	- [位数 Bit 维度](#%E4%BD%8D%E6%95%B0%20Bit%20%E7%BB%B4%E5%BA%A6)
- [案例分析](#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90)
	- [普通情况](#%E6%99%AE%E9%80%9A%E6%83%85%E5%86%B5)
	- [JVM 中](#JVM%20%E4%B8%AD)
		- [字符串存储分析](#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90)
		- [JVM 中两百万个字符串的总内存占用](#JVM%20%E4%B8%AD%E4%B8%A4%E7%99%BE%E4%B8%87%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%80%BB%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8)
		- [注意](#%E6%B3%A8%E6%84%8F)

## 三个长度单元

### 字符 character 维度

字符不分中西！比如，字符串 " 我爱 b" 由三个字符组成：两个中文字符 " 我 " 和 " 爱 "，以及一个英文字符 "b"。总计，这个字符串是由三个字符构成的。在编码中，字符的数量是指字符串中的元素总数，不论这些字符是属于*哪种语言或符号系统*。

### 字节 Byte 维度

| 类型   | 字符示例    | ASCII 字节数 | UTF-8 字节数 | UTF-16 字节数 |
|------|---------|-----------|-----------|------------|
| 英文字符 | A, z, 1 | 1 字节      | *1 字节*    | 2 字节       |
| 中文字符 | 中, 文    | 不适用       | *3 字节*    | 2 字节       |
| 特殊符号 | @, #, $ | 1 字节      | 1 字节      | 2 字节       |
| 特殊符号 | €, ©, ¼ | 不适用       | 2-3 字节    | 2 字节       |
| 表情符号 | 😊, 🚀  | 不适用       | 4 字节      | 4 字节       |  

UTF-8 里一个中文字符需要 3 字节，Java 里一个 char 是 2byte，如果用 UTF-8 岂不是就不够了，所以其实 Java 用的是 UTF-16

### KB，MB

知道字节就可以算我们常说的 KB 和 MB 了

1. **1 Kilobyte (KB)**:
    - **在二进制计数系统中**，1 KB 等于 210210 字节，也就是 1024 字节。
    - 因此，1 KB 等于 1024×8=81921024×8=8192 bits。
2. **1 Megabyte (MB)**:
    - **在二进制计数系统中**，1 MB 等于 220220 字节，也就是 1,048,576 字节。
    - 因此，1 MB 等于 1,048,576×8=8,388,6081,048,576×8=8,388,608 bits。

### 位数 Bit 维度

1 byte = 8 bits

 不管啥字符集，1 byte = 8 bits，代表 256 种变换，所以表示英文绰绰有余  
UTF-16 里， 2 byte = 16 bits，代表 6w 种变换，表示中文也绰绰有余了  
UTF-8 里， 3 byte = 24 bits，代表 1600w 种变换，表示中文 更富裕了

## 案例分析

> "beijing_11352" 是多少字符，多少 byte，多少 bit？多少 KB？多少 MB？

### 普通情况

200w（个数）* 12（字符数）* 2（由字符集决定）= 40000000 byte = 40MB

### JVM 中

  

在 Java 虚拟机（JVM）中处理两百万个 "beijing_11352" 字符串的内存占用，还需要考虑到 JVM 对字符串的特殊处理和管理。这包括字符串对象的开销、字符串池的可能影响（如果字符串被内部化），以及字符数组本身的存储开销。

#### 字符串存储分析

1. **基本存储**：
    
    - 一个 "beijing_11352" 字符串由 12 个字符组成，使用 UTF-16 编码（Java 的默认字符编码）。在 UTF-16 中，大多数字符（包括所有基本多语言平面（BMP）的字符）占用 2 个字节。因此，每个字符串的字符数组需要 12×2=2412×2=24 bytes。
    
2. **字符串对象的开销**：
    
    - 每个 Java 对象都有一个对象头。在大多数 64 位 JVM 上，对象头通常占用 12 bytes。另外，对于数组对象，还需要额外的空间来存储长度信息，通常是 4 bytes。
    - 因此，每个字符串对象的总开销包括对象头和字符数组的开销：12+4+24=4012+4+24=40 bytes。

#### JVM 中两百万个字符串的总内存占用

1. **总内存开销**：
    
    - 如果没有字符串内部化或优化（比如字符串去重），每个字符串的存储开销为 40 bytes，两百万个字符串则需要：40 bytes×2,000,000=80,000,000 bytes40bytes×2,000,000=80,000,000bytes
2. **转换为 KB 和 MB**：
    
    - 80,000,000 bytes1024≈78,125 KB102480,000,000bytes​≈78,125KB
    - 80,000,000 bytes1024×1024≈76.294 MB1024×102480,000,000bytes​≈76.294MB

#### 注意

- **字符串池**：在 Java 中，字符串字面量自动被内部化，存储在 JVM 的字符串池中。如果这些字符串是动态生成的并且不被显式地内部化（使用 `String.intern()`），则每个字符串都将占用独立的内存空间。如果使用字符串字面量或已内部化的字符串，那么内存占用可能会减少，因为多个字符串引用将指向内存中的同一对象。
- **压缩指针**：在较新的 JVM 实现中，如果堆大小小于 32GB，通常可以使用压缩指针，这可能减少对象引用所需的空间，从而略微降低每个字符串对象的内存占用。

总结来说，两百万个 "beijing_11352" 字符串在没有特别优化的情况下，大约需要 76.294 MB 的内存，这考虑了每个字符串实例和字符数组的存储需求。

- [ ] java 中的字符串为什么从 char 数组换成了 byte 数组 ⏰ 2024-04-30 📅 2024-04-30



[数据/时序数据库.md]
=============

---
draw:
title: 时序数据库
tags: [信息革命, 数据]
date created: 2024-04-25
date modified: 2024-11-12
---

excerpt

<!-- more -->

时序数据库

> Prometheus 是一套开源的系统监控报警框架。它的核心功能是从被监控系统中拉取监控数据，结合 Grafana 工具，进行可视化展示。而且，监控数据可以保存到时序数据库中，以便运维人员进行历史查询。同时，Prometheus 会检测系统的监控指标是否超过了预设的阈值，一旦超过阈值，Prometheus 就会触发报警。



[数据/行式存储和列式存储.md]
=================

---
draw:
title: 行式存储和列式存储
tags: []
date created: 2024-06-05
date modified: 2024-11-12
---

excerpt

<!-- more -->

列式存储（Columnar Storage）和行式存储（Row Storage）是两种不同的数据存储方式。列式存储通常在某些场景下比行式存储更高效，特别是在数据分析和查询操作中。以下是列式存储通常比行式存储更高效的原因：

  

**1. 数据压缩效率**

  

- **列式存储**：由于同一列的数据类型相同，并且经常具有相似的值（如重复或范围较小的数值），列式存储的数据压缩效率通常较高。可以使用更高级的压缩算法，如 RLE（Run Length Encoding）、字典编码等。
- **行式存储**：行式存储每一行的数据类型可能不同，数据的相似性较低，压缩效率较差。

  

**2. 查询性能**

  

- **列式存储**：在进行聚合查询和分析查询时，通常只需要访问所需的列。例如，计算某列的平均值或求和时，只需读取该列的数据，大大减少了 I/O 操作。
- **行式存储**：查询时需要读取整个行的数据，即使只需要其中的几列，这会增加不必要的 I/O 开销。

  

**3. 内存使用效率**

  

- **列式存储**：因为只读取所需的列，内存使用更高效。可以加载更多的列数据到内存中，从而提高查询性能。
- **行式存储**：由于需要读取和处理整个行的数据，内存使用效率较低，尤其在只需要部分列的查询中。

  

**4. 矢量化处理**

  

- **列式存储**：列式存储适合矢量化处理，CPU 可以更有效地对列数据进行批量处理，利用现代 CPU 的指令集进行并行计算，提高处理速度。
- **行式存储**：行式存储在矢量化处理方面不如列式存储高效，因为每次处理时都要解码整行数据。

  

**5. 缓存命中率**

  

- **列式存储**：由于连续的同一列的数据存储在一起，可以更好地利用 CPU 缓存，提高缓存命中率，减少内存访问次数。
- **行式存储**：数据存储在一行中，不同列的数据存储位置不连续，缓存命中率较低。

  

**适用场景**

  

- **列式存储**：适用于数据分析、OLAP（Online Analytical Processing）系统、大规模数据仓库、需要频繁读取和聚合操作的场景。
- **行式存储**：适用于 OLTP（Online Transaction Processing）系统、事务处理系统、需要频繁插入、更新和删除操作的场景。

  

**总结**

  

列式存储通过提高数据压缩效率、减少 I/O 操作、优化内存使用、支持矢量化处理以及提高缓存命中率，在大规模数据分析和查询操作中比行式存储更加高效。



[数据库@.md]
=========

---
draw:
tags: []
title: 数据库@
date created: 2024-08-07
date modified: 2024-11-12
---

[三范式](三范式.md)

应届生如何半年找到一份数据库内核开发的工作 - Smith 的文章 - 知乎  
https://zhuanlan.zhihu.com/p/490171772

- [关系型数据库](关系型数据库)：
	- [MySQL](MySQL.md)
	- postgreSQL
- [key-value数据库](key-value数据库)：
	- redis
	- etcd
- [文档数据库](文档数据库)：
	- mongoDB
	- cassandra(宽列数据库)
- 全文搜索引擎：
	- Elasticsearch -- 云，微服务兴起，可观察性要求高

[向量数据库](向量数据库.md)

由于其需要基于 C++17 实现，而本人在目前没有太多的 C++ 知识储备，所以就暂时搁置了，毕竟想学的是数据库而不是 C++。不过我也注意到，MIT 6.830 数据库课程的作业 [simple-db](https://github.com/MIT-DB-Class/simple-db-hw-2021) 是基于 Java 的，且其 6 个 lab 的内容基本覆盖了 CMU 15-445 lab 的内容，所以刷一刷 MIT 6.830 的 lab 也挺有意义的，希望自己后半年能抽出些时间吧。

![image.png|1000](https://imagehosting4picgo.oss-cn-beijing.aliyuncs.com/imagehosting/fix-dir%2Fpicgo%2Fpicgo-clipboard-images%2F2024%2F08%2F10%2F21-18-38-060c5ca071d89134b15b75a748cc8a97-202408102118732-c6c63a.png)



[数据库最佳实践/1 建表 5-10.md]
======================

---
draw:
title: 1 建表 5-10
tags: [信息革命, 数据, 数据库最佳实践]
date created: 2024-04-17
date modified: 2024-12-27
---

excerpt

<!-- more -->

9.【强制】表必备三字段：id，create_time，update_time。

> 说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time，update_time 的类型均为  
datetime 类型，如果要记录时区信息，那么类型设置为 timestamp。

1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。

> 注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在`<resultMap>`设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。说明：任何字段如果为非负数，必须是 unsigned。正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。

4.【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。

6.【强制】小数类型为 decimal，禁止使用 float 和 double。

> 说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存  
  储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。

10.【强制】在数据库中不能使用物理删除操作，要使用逻辑删除。

> 说明：逻辑删除在数据删除后可以追溯到行为操作。不过会使得一些情况下的唯一主键变得不唯一，需要根据情况来酌  
  情解决。



[数据库最佳实践/2 加索引 4.md]
====================

---
draw:
title: 2 加索引 4
tags: [信息革命, 数据, 数据库最佳实践]
date created: 2024-04-17
date modified: 2024-11-12
---

excerpt

<!-- more -->



[数据库最佳实践/3 写SQL  9.md]
======================

---
draw:
title: 3 写SQL  9
tags: [信息革命, 数据, 数据库最佳实践]
date created: 2024-04-17
date modified: 2024-11-12
---

excerpt

<!-- more -->



[数据库最佳实践/ClickHouse.md]
=======================

---
draw:
title: ClickHouse
tags: [信息革命, 数据, 数据库最佳实践]
date created: 2024-05-01
date modified: 2024-11-12
---

excerpt

<!-- more -->



[数据库最佳实践/PG 数据导出迁移.md]
======================

---
draw:
title: PG 数据导出迁移
tags: [信息革命, 数据, 数据库最佳实践]
date created: 2024-05-01
date modified: 2024-12-27
---

excerpt

<!-- more -->

PostgreSQL（通常称为 PG 库）的数据实际上存储在文件系统的一组文件中，这些文件位于服务器上的一个特定目录中。这个目录被称为数据目录，通常在 PostgreSQL 配置文件（`postgresql.conf`）中设置为 `data_directory`。

## 数据存储位置

1. **数据文件**：表数据、索引等都存储在数据目录中的文件里。
2. **事务日志（WAL）文件**：这些是用于数据恢复和确保数据完整性的日志文件。
3. **配置文件**：如 `postgresql.conf` 和 `pg_hba.conf` 等配置文件也位于此目录。

## 数据导出与迁移

迁移 PostgreSQL 数据库通常涉及数据的备份与恢复。下面是一些常用的方法：

### 1. SQL 转储（pg_dump 和 pg_dumpall）

- **pg_dump**：用于导出一个或多个数据库的数据和结构到一个文件中。这个文件可以是 SQL 语句的集合，也可以是二进制格式。
    

    bash

    

    Copy code

    

    `pg_dump -U username -W -F c -b -v -f "/path/to/your/file.backup" dbname`

    

    这条命令会提示你输入密码，然后创建一个格式化的备份文件。

    
- **pg_dumpall**：导出整个数据库服务器的所有数据库和角色数据。
    

    bash

    

    Copy code

    

    `pg_dumpall -U username -W -f "/path/to/your/file.sql"`

    

    这会生成一个 SQL 脚本文件，包括创建数据库和用户的命令。

    

### 2. 物理备份（文件系统级备份）

- **直接复制数据目录**：在数据库停机的情况下，可以直接复制整个数据目录到另一位置或另一服务器。
- **使用工具如 rsync**：对于较大的



[数据库最佳实践/为什么要用数据库？.md]
======================

---
draw:
title: 为什么要用数据库？
tags: [信息革命, 数据, 数据库最佳实践]
date created: 2024-05-01
date modified: 2024-11-12
---

为什么要用数据库，直接把数据存在 excel 或者 txt 中不行吗？

<!-- more -->

使用数据库而不是直接将数据存储在 Excel 或文本文件（txt）中的原因主要包括以下几点：

1. **数据管理能力**：数据库提供了强大的数据管理能力，包括数据的增删改查、索引、排序等。这使得处理大量数据变得更加高效和可靠。
    
2. **数据完整性和一致性**：数据库能够确保数据的完整性和一致性。通过设置数据类型、约束（如主键、外键、唯一性约束等）和事务管理，可以防止数据出现冗余或错误。
    
3. **并发控制**：数据库支持多用户同时访问数据，通过锁定机制和事务处理，保证了数据访问的一致性和安全性，这在多用户环境中非常重要。
    
4. **安全性**：数据库提供了访问控制和安全措施，例如用户权限管理和加密，保护数据不被未授权访问或篡改。
    
5. **可扩展性和性能**：随着数据量的增加，数据库能够提供良好的性能和可扩展性。数据库管理系统（DBMS）设计有优化查询和处理大量数据的算法。
    
6. **数据备份和恢复**：数据库系统通常包含数据备份和恢复功能，可以在数据丢失或损坏时快速恢复数据。
    

相比之下，使用 Excel 或文本文件存储数据虽然在小规模或少量数据处理时比较简单方便，但在处理大量数据、需要多用户并发访问或要求高数据安全性的场景下，其功能和效率会受到限制。特别是在数据规模较大、复杂度较高的商业环境中，数据库是更优的选择。



[非结构化数据.md]
===========

---
draw:
tags: []
title: 非结构化数据
date created: 2024-10-03
date modified: 2024-11-12
---

结构化数据和非结构化数据是对数据类型的一种分类，主要根据数据的组织方式和格式来区分。作为一个会Java的十岁小朋友，你可以把它们想象成有组织的和没有组织的数据。

  

结构化数据

  

定义：结构化数据是指以固定格式组织的数据，具有明确的字段和类型，类似于数据库中的表格。

  

特点：

  

- 固定的格式和字段：数据被预先定义的模型所组织。
- 容易存储和查询：可以使用SQL等查询语言方便地进行数据操作。
- 示例：
- 数据库表：想象一个表格，每一行代表一条记录，每一列代表一个字段。
- 在Java中：一个类的对象，每个对象都有相同的属性。

  

Java示例：

  

public class ChatMessage {

    private String sender;

    private String timestamp;

    private String content;

  

    // 构造函数、getter和setter方法

}

  

在这个例子中，每个ChatMessage对象都有相同的属性，这就是结构化数据。

  

非结构化数据

  

定义：非结构化数据是指没有预定义格式或模型的数据，内容可能是任意形式的。

  

特点：

  

- 无固定格式：数据没有统一的结构，可能包含各种类型的信息。
- 处理复杂：需要额外的工具或步骤来提取有用的信息。
- 示例：
- 文本文件：像小说、聊天记录的纯文本。
- 多媒体文件：图片、音频、视频等。
- 在Java中：一个字符串，内容未知或格式不固定。

  

Java示例：

  

String unstructuredData = "小明：今天天气真好！";

  

这个字符串可能包含发送者、时间和内容，但需要解析才能提取出这些信息。

  

在聊天记录分析中的应用

  

当你想分析一个群的聊天记录时：

  

- 结构化部分：如果你的聊天记录已经被整理成固定的格式，比如每条消息都有明确的发送者、时间和内容字段，那么你可以直接存储和查询这些数据。
- 非结构化部分：如果聊天记录只是纯文本，所有信息都混在一起，那么你需要先对数据进行处理（比如使用正则表达式或自然语言处理技术）来提取出有用的信息。

  

示例：

  

假设你有以下聊天记录：

  

[2023-10-01 10:00]小明：早上好！

[2023-10-01 10:05]小红：小明早上好！

  

要把它变成结构化数据，你可以解析出每条消息的发送者、时间和内容，然后存储在一个ChatMessage对象中。

  

为什么区分结构化和非结构化数据很重要？

  

- 处理方法不同：结构化数据可以直接使用数据库查询，而非结构化数据需要先进行解析和处理。
- 存储方式不同：结构化数据适合存储在关系型数据库中，非结构化数据可能需要NoSQL数据库或文件系统。

  

总结

  

- 结构化数据：数据有固定的格式，容易存储、查询和分析。
- 非结构化数据：数据没有固定的格式，需要额外的步骤来处理。

  

希望这个解释能帮助你理解结构化和非结构化数据的区别！如果你有更多问题，欢迎继续提问。


